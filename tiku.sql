-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: localhost    Database: tiku
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `tiku`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `tiku` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `tiku`;

--
-- Table structure for table `exercises`
--

DROP TABLE IF EXISTS `exercises`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `exercises` (
  `e_id` int(11) unsigned zerofill NOT NULL AUTO_INCREMENT,
  `e_desc` varchar(5000) NOT NULL,
  `e_answer` varchar(5000) DEFAULT NULL,
  `e_diff` varchar(45) NOT NULL,
  `e_type` varchar(45) NOT NULL,
  `e_point` varchar(45) NOT NULL,
  `e_img` varchar(100) DEFAULT NULL,
  `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `e_tag` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`e_id`),
  UNIQUE KEY `e_id_UNIQUE` (`e_id`)
) ENGINE=InnoDB AUTO_INCREMENT=680 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `exercises`
--

LOCK TABLES `exercises` WRITE;
/*!40000 ALTER TABLE `exercises` DISABLE KEYS */;
INSERT INTO `exercises` VALUES (00000000001,'test_desc','test_answer','test_diff','test_type','test_point',NULL,'2017-03-09 08:26:47',NULL),(00000000454,'1#!J2EE是什么？它包括哪些技术？\n\n','解答：从整体上讲，J2EE是使用Java技术开发企业级应用的工业标准，它是Java技术不断适应和促进企业级应用过程中的产物。适用于企业级应用的J2EE，提供一个平台独立的、可移植的、多用户的、安全的和基于标准的企业级平台，从而简化企业应用的开发、管理和部署。J2EE是一个标准，而不是一个现成的产品。\n\n主要包括以下这些技术：\n\n1) Servlet Servlet是Java平台上的CGI技术。Servlet在服务器端运行，动态地生成Web页面。与传统的CGI和许多其它类似CGI的技术相比，Java Servlet具有更高的效率并更容易使用。对于Servlet，重复的请求不会导致同一程序的多次转载，它是依靠线程的方式来支持并发访问的。 2)JSP JSP(Java Server Page)是一种实现普通静态HTML和动态页面输出混合编码的技术。从这一点来看，非常类似Microsoft ASP、PHP等技术。借助形式上的内容和外观表现的分离，Web页面制作的任务可以比较方便地划分给页面设计人员和程序员，并方便地通过JSP来合成。在运行时态，JSP将会被首先转换成Servlet，并以Servlet的形态编译运行，因此它的效率和功能与Servlet相比没有差别，一样具有很高的效率。 3) EJB EJB定义了一组可重用的组件：Enterprise Beans。开发人员可以利用这些组件，像搭积木一样建立分布式应用。 4)JDBC\n\nJDBC(Java Database Connectivity，Java数据库连接)API是一个标准SQL(Structured Query Language，结构化查询语言)数据库访问接口，它使数据库开发人员能够用标准Java API编写数据库应用程序。JDBC API主要用来连接数据库和直接调用SQL命令执行各种SQL语句。利用JDBC API可以执行一般的SQL语句、动态SQL语句及带IN和OUT参数的存储过程。Java中的JDBC相当于Microsoft平台中的ODBC(Open Database Connectivity)。\n\n','5','saq','前端',NULL,'2017-03-12 14:50:28',NULL),(00000000455,'测试生命周期、测试过程分为几个阶段，以及各阶段的含义？\n\n','解答：软件测试生命周期一般包括6个阶段：1）计划 2）分析，3）设计，4）构建，5）测试周期，6）最后测试和实施，\n\n1） 计划：产品定义阶段\n\n2). 分析:外部文档阶段\n\n3). 设计:文档架构阶段\n\n4). 构建:单元测试阶段\n\n5). 测试周期:错误修正,重复系统测试阶段\n\n6). 最后的测试和实施:代码冻结阶段\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:28',NULL),(00000000456,'您做系统设计用何种工具？\n\n','解答：Visio, rational rose，power designer等 4. 什么是Web容器?\n\n解答：容器就是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:28',NULL),(00000000457,' 运行时异常与一般异常有何异同？\n\n','解答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。\n\n','4','saq','后台',NULL,'2017-03-12 14:50:28',NULL),(00000000458,' Hibernate中：不看数据库，不看XML文件，不看查询语句，怎么样能\n\n知道表结构？\n\n','解答：可以看与XML文件对应的域模型。\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:28',NULL),(00000000459,'目前几种主流数据库软件的应用特点、适用范围各是什么？\n\n','解答：国际国内的主导关系型数据库管理系统有SQL Server、ORACLE、SYBASE、INFORMIX和 DB2。本文从性能，可伸缩性和并行性，安全性，操作简便，使用风险，开放性，易维护性和价格，数据库二次开发方面比较了SQL Server，Oracle、SYBASE、DB2、INFORMIX 数据库：\n\n1）性能\n\nSQL Server：老版本多用户时性能不佳，新版本的性能有了明显的改善，各项处理能力都有了明显的提高。保持了多项TPC-C（TPC-C值被广泛用于衡量C/S环境下,由服务器和客户端构筑的整体系统的性能,它由事物处理性能委员会（TPC，Transaction Processing Corp）制定,TPC为非赢利性国际组织。）纪录。\n\nOracle ：性能最高， 保持Windows NT下的TPC-C的世界记录。 SYBASE ：性能较高，支持Sun、IBM、HP、Compaq和Veritas的集群设备的特性，实现高可用性。适应于安全性要求极高的系统。 DB2 ：适用于数据仓库和在线事物处理，性能较高。 客户端支持及应用模式。 INFORMIX ：性能较高，支持集群，实现高可用性。适应于安全性要求极高的系统，尤其是银行，证券系统的应用。 2）可伸缩性,并行性 SQL Server ：以前版本SQL Server并行实施和共存模型并不成熟。很难处理大量的用户数和数据卷。伸缩性有限。新版本性能有了较大的改善，在Microsoft Advanced Servers上有突出的表现，超过了他的主要竞争对手。\n\nOracle ：平行服务器通过使一组结点共享同一簇中的工作来扩展Window NT的能力,提供高可用性和高伸缩性的簇的解决方案。如果Windows NT不能满足需要, 用户可以把数据库移到UNIX中，具有很好的伸缩性。 SYBASE ：新版本具有较好的并行性，速度快，对巨量数据无明显影响，但是技术实现复杂，需要程序支持，伸缩性有限。 DB2 ：DB2具有很好的并行性。DB2把数据库管理扩充到了并行的、多节点的环境。数据库分区是数据库的一部分，包含自己的数据、索引、配置文件、和事务日志。数据库分区有时被称为节点或数据库节点，伸缩性有限。 INFORMIX ：采用单进程多线程的技术，具有较好的并行性。但是仅运行于UNIX平台，伸缩性有限。 3）安全性 SQL server ：Microsoft Advanced Server 获得最高安全认证，服务器平台的稳定性是数据库的稳定性的基础，新版本的SQL的安全性有了极大的提高。 Oracle：获得最高认证级别的ISO标准认证。 SYBASE ：通过Sun公司J2EE认证测试，获得最高认证级别的ISO标准认证。 DB2 ：获得最高认证级别的ISO标准认证。 INFORMIX ：获得最高认证级别的ISO标准认证。 4）操作简便 SQL Server ：操作简单,采用图形界面。管理也很方便，而且编程接口特别友好(它的SQL-DMO让编程变得非常方便！) ，从易维护性和价格上SQL Server明显占有优势。 Oracle ：较复杂, 同时提供GUI和命令行，在Windows NT和Unix， Linux 下操作相同。对数据库管理人员要求较高。 SYBASE ：复杂，使用命令行操作，对数据库管理人员要求较高。 DB2 ：操作简单,同时提供GUI和命令行，在Windows NT和Unix下操作相同。 INFORMIX ：使用和管理复杂，命令行操作。对数据库管理人员要求较高。 5）使用风险 SQL Server ：完全重写的代码，性能和兼容性有了较大的提高，与Oracle，DB2的性能差距明显减小。该产品的出台经历了长期的测试，为产品的安全和稳定进行了全面的检测，安全稳定性有了明显的提高。 Oracle ：长时间的开发经验，完全向下兼容，可以安全的进行数据库的升级，在企业，政府中得到广泛的应用。并且如果在WINNT上无法满足数据的要求，可以安全的把数据转移到UNIX上来。\n\nSYBASE ：开发时间较长，升级较复杂，稳定性较好，数据安全有保障。风险小。在安全要求极高的银行，证券行业中得到了广泛的应用。 DB2 ：在巨型企业得到广泛的应用，向下兼容性好。风险小。 INFORMIX ：开发时间较长，升级较复杂，稳定性较好，数据安全有保障。风险小。在安全要求极高的银行，证券行业中得到了广泛的应用。 6）开放性 SQL Server：只能在Windows 上运行，C/S结构，只支持Windows客户，可以用ADO,DAO,OLEDB,ODBC连接。Windows9X系列产品是偏重于桌面应用，NT server适合各种大中小型企业。 操作系统的稳定对数据库是十分重要的。Windows平台的可靠性，安全性经过了最高级别的C2认证的。在处理大数据量的关键业务时提供了较好的性能。 Oracle ：能在所有主流平台上运行（包括 Windows）。完全支持所有的工业标准。采用完全开放策略。多层次网络计算，支持多种工业标准，可以用ODBC,JDBC,OCI等网络客户连接。可以使客户选择最适合的解决方案。对开发商全力支持。 SYBASE ：能在所有主流平台上运行，在银行业中得到了广泛的应用。 DB2 ：有较好的开放性，最适于海量数据。跨平台，多层结构，支持ODBC,JDBC等客户。在大型的国际企业中得到最为广泛的应用,在全球的500家最大的企业中,大部分采用DB2数据库服务器。 IINFORMIX ：仅运行在UNIX平台，包括SUNOS、HPUX、 ALFAOSF/1。在银行中得到广泛的应用。 7）易维护性和价格 SQL Server :从易维护性和价格上SQL Server明显占有优势。基于Microsoft的一贯风格，SQL Server的图形管理界面带来了明显的易用性， 微软的数据库管理员培训进行的比较充分，可以轻松的找到很好的数据库管理员，数据库管理费用比较低，SQL Server的价格也是很低的，但是在License的购买上会抬高价格。总体来说SQL Server的价格在商用数据库中是最低的。 Oracle :从易维护性和价格上来说Oracle的价格是比较高的，管理比较复杂，由于Oracle的应用很广泛，经验丰富的Oracle数据库管理员可以比较容易的找到，从而实现Oracle的良好管理。因此Oracle的性能价格比在商用数据库中是最好的。 SYBASE :SYBASE的价格是比较低的，但是SYBASE的在企业和政府中的应用较少，很难找到经验丰富的管理员，运行管理费用较高。\n\nDB2 :价格高， 管理员少，在中国的应用较少，运行管理费用都很高，适用于大型企业的数据仓库应用。 INFORMIX :价格在这些系统中居于中间，与SYBASE一样，在企业和政府中应用较少，仅在银行中得\n\n到了广泛的应用。经验丰富的管理人员较少，运行管理费用高。 8)数据库二次开发 SQL Server :数据库的二次开发工具很多，包括Visual C++, Visual Basic等开发工具，可以实现很好的Windows应用，开发容易。 Oracle :数据库的二次开发工具很多，涵盖了数据库开发的各个阶段，开发容易。 SYBASE :开发工具较少，经验丰富的人员很少。 DB2 :在国外巨型企业得到广泛的应用，中国的经验丰富的人员很少。 INFORMIX :在银行业中得到广泛的应用，但是在中国的经验丰富的人员很少。\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:28',NULL),(00000000460,'存储过程和函数的区别\n\n','解答：\n\n从参数的返回情况来看：\n\n如果返回多个参数值最好使用存储过程，如果只有一个返回值的话可以使用函数。\n\n从调用情况来看：\n\n如果在SQL语句（DML或SELECT）中调用的话一定是存储函数或存储的封装函数不可以是存储过程，但调用存储函数的时候还有好多限制以及函数的纯度等级的问题，如果是在过程化语句中调用的话，就要看你要实现什么样的功能。函数一般情况下是用来计算并返回一个计算结果而存储过程一般是用来完成特定的数据操作（比如修改、插入数据库表或执行某些DDL语句等等），所以虽然他们的语法上很相似但用户在使用他们的时候所需要完成的功能大部分情况下是不同的。\n\n','4','saq','前端',NULL,'2017-03-12 14:50:28',NULL),(00000000461,'试述数据库完整保护的主要任务和措施。\n\n','解答：数据库的完整性保护也就是数据库中数据正确性的维护。数据库完整性包括三个内容：实体完整性规则，参照物完整性规则以及用户定义完整性规则。 前两个是有DBMS自动处理。\n\n实体完整性规则是说针对于基表中的关键字中属性值不能为空值，是数据库完整性的基本要求，主关键字和元组的唯一性对应。\n\n参照物完整性规则是不允许引用不存在的元组：即基表中的外关键字要么为空，要么关联基表中必存在元组。\n\n用户定义完整性规则针对具体的数据环境由用户具体设置的规则，它反应了具体应用中的语义要求。 一个完整性规则一般由下面三部分组成:完整性约束条件设置,完整性约束条件的检查以及完整性约束条件的处理.后两部分在数据库中一般有相应的模块处理。另外触发器也可以做完整性的保护，但触发器大量用于主动性领域。\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:28',NULL),(00000000462,'请说明SQLServer中delete from tablea & truncate table tablea的区别\n\n','解答：两者都可以用来删除表中所有的记录。区别在于：truncate是DDL操作，它移动HWK，使HWK值为0，不需要 rollback segment .而Delete是DML操作需要rollback segment 且花费较长时间.\n\n','2','saq','后台',NULL,'2017-03-12 14:50:28',NULL),(00000000463,' Oracle安装完成后,如何用命令行启动和关闭数据库?\n\n','解答：\n\n打开：STARTUP [FORCE] [RESTRICT] [PFILE= filename] [OPEN [RECOVER][ database] | MOUNT | NOMOUNT] STARTUP OPEN：STARTUP缺省的参数就是OPEN，打开数据库，允许数据库的访问。当前实例的控制文件中所描述的所有文件都已经打开。 STARTUP MOUNT：MOUNT数据库，仅仅给DBA进行管理操作，不允许数据库的用户访问。仅仅只是当前实例的控制文件被打开，数据文件未打开。 STARTUP NOMOUNT：仅仅通过初始化文件，分配出SGA区，启动数据库后台进程，没有打开控制文件和数据文件。不能访问任何数据库。 STARTUP PFILE= filename：以filename为初始化文件启动数据库，不是采用缺省初始化文件。 STARTUP FORCE：中止当前数据库的运行，并开始重新正常的启动数据库。 STARTUP RESTRICT：只允许具有RESTRICTED SESSION权限的用户访问数据库。 STARTUP RECOVER：数据库启动，并开始介质恢复\n\n关闭\n\nSHUTDOWN有四个参数：NORMAL、TRANSACTIONAL、IMMEDIATE、ABORT。缺省不带任何参数时表示是NORMAL。\n\n命令SHUTDOWN NORMAL：不允许新的连接、等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。 SHUTDOWN TRANSACTIONAL：不允许新的连接、不等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。 SHUTDOWN IMMEDIATE：不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。没有结束的事务是自动rollback的。启动时不需要实例恢复。 SHUTDOWN ABORT：不允许新的连接、不等待会话结束、不等待事务结束、不做检查点且没有关闭数据文件。启动时自动进行实例恢复。 另外，对于NORMAL、TRANSACTIONAL、IMMEDIATE，DB Buffer Cache的内容写入了数据文件，没有提交的事务被回滚，所有的资源被释放，数据库被“干净”的关闭。 对于ABORT，DB Buffer Cache的内容没有写入数据文件，没有提交的事务也没有回滚。数据库没有dismount和关闭，数据文件也没有关闭。当数据库启动时，需要通过redo log恢复数据，通过回滚\n\n段对事务回滚，对资源进行释放。\n\n','2','saq','后台',NULL,'2017-03-12 14:50:28',NULL),(00000000464,' 类有哪三个基本特性？各特性的优点？\n\n','解答：类具有封装性、继承性和多态性。\n\n封装性：类的封装性为类的成员提供公有、缺省、保护和私有等多级访问权限，目的是隐藏类中的私有变量和类中方法的实现细节。\n\n继承性：类的继承性提供从已存在的类创建新类的机制，继承（inheritance）使一个新类自动拥有被继承类（父类）的全部可继承的成员。\n\n多态性：类的多态性提供类中方法执行的多样性，多态性有两种表现形式：重载和覆盖。\n\n','2','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000465,'谈谈对XML的理解？说明Web应用中WeB、xml文件的作用？\n\n','解答：XML（Extensible Markup Language）即可扩展标记语言，它与HTML一样，都是SGML(Standard Generalized Markup Language,标准通用标记语言)。Xml是Internet环境中跨平台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言XML是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然XML占用的空间比二进制数据要占用更多的空间，但XML极其简单易于掌握和使用。\n\nweB、xml的作用是配置欢迎页，servlet，filter，listener等的。\n\n','1','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000466,'jsp有哪些内置对象？作用分别是什么？（至少三个）\n\n','解答：\n\n1）request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header和session数据的有用的方法。 2）response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等）。 3）out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 4）pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 5）session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息。 6）application 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息。 7）config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参\n\n数。 8）page表示从该页面产生的一个servlet实例。\n\n9）exception 针对错误网页，未捕捉的例外\n\n','5','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000467,'事务是什么？有哪些属性，并简要说明这些属性的含义。\n\n','解答：事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。\n\n事务应该具有4个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为ACID特性。\n\n原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n\n一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n\n隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n\n持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000468,'Collection 和 Collections的区别？\n\n','解答：Collection是javA、util下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List；Collections是个javA、util下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000469,'HashMap与TreeMap的区别？\n\n','解答：HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。\n\n','1','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000470,'ArrayList和Vector的区别？\n\n','解答：同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程不安全的，不是同步的；数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半。\n\n','4','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000471,'HashMap和Hashtable的区别？\n\n','解答：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都实现了Map接口，主要区别\n\n在于HashMap允许空（null）键值（key）,由于非线程安全，效率上高于Hashtable。HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。最大的不同是，Hastable的方法是synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供同步。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000472,'请说出ArrayList,Vector, LinkedList的存储性能和特性\n\n','解答：ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000473,' 描述J2EE框架的多层结构，并简要说明各层的作用。\n\n','解答：\n\n1) Presentation layer（表示层）\n\nA、 表示逻辑（生成界面代码）\n\nB、 接收请求\n\nC、 处理业务层抛出的异常\n\nD、 负责规则验证（数据格式，数据非空等）\n\ne. 流程控制\n\n2) Service layer（服务层/业务层）\n\nA、封装业务逻辑处理，并且对外暴露接口\n\nB、负责事务，安全等服务\n\n3) Persistence layer（持久层）\n\na 封装数据访问的逻辑，暴露接口\n\nB、提供方便的数据访问的方案（查询语言，API，映射机制等）\n\n4）Domain layer（域层）\n\nA、 业务对象以及业务关系的表示\n\nB、 处理简单的业务逻辑\n\nC、 域层的对象可以穿越表示层，业务层，持久层\n\n软件分层结构使得代码维护非常方便，设计明确，各层独立，专注自己擅长的领域。\n\n','4','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000474,'请谈谈对SOA的认识。\n\n','解答：面向服务的体系结构（Service-Oriented Architecture，SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。\n\n','3','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000475,'简要描述如何结合struts、hibernate、spring开发Web应用？\n\n','解答：Struts可以将jsp页面的表单关联起来,就是把JSP页面的表单数据封装成javaBean,这样的话,在action中你再也不需要使用传统的request.getParameter(“name”);还有struts有一个控制器,你在struts编程中的控制器(XxxAction)都是继承总的ActionServlet,它能集中处理请求,然后转到相关的页面。还有struts的表单验证组件,不用你写js验证了,只需要你配置一下文件就可以了。另外struts的令牌机制可以防表单重复提交。\n\nSpring 是一个轻量级容器,非侵入性.包含依赖注入,AOP等。它是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。\n\nHibernate:它可以让我们以OO的方式操作数据库，这让我们看到了hibernate的强大之处，体验到操作数据的方便。但hibernate最耀眼之处是hibernate的缓存机制，而不是以OO的方式操作数据库。Hibernate的缓存机制不外乎是一级缓存session，二级缓存sessionFactory，和第三方缓存如ehcache。也就是hibernate的最强大的地方是它的缓存，理解了这个才能真正的理解hibernate,Hibernate的命名查询/命名参数查询，就是将hql语句放在一个单独的xml文件之中，它仍然让人们以面向对象的方式去操纵数据，而不用在以OO的方式写着代码的同时，然后再转变思维，用面向关系的方式去写那些sql语句。但hibernate不仅做了这些，它的native sql查询方式，完全满足sql语句的偏爱者，它像ibatis一样，将sql语句放在配置文件之中。\n\n','5','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000476,'说明反转控制（IOC）和面向方向编程（AOP）在spring中的应用\n\n','解答：Spring 核心容器（Core）提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory使用控制反转（Ioc）模式将应用程序的配置和依赖性规范与实际的应用代码程序分开。Spring的声明式事务基于AOP实现，却并不需要程序开发者成为AOP专家，亦可轻易使用Spring的声明式事务管理。\n\n','4','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000477,'请看如下片段：\n\n<set name=“address”\n\nlazy=“true”\n\ninverse=“false”\n\ncascade=“all-delete-orphan”>\n\n<key column = “USERID”> </key>\n\n<one-to-many class=“com.norteksoft.erm.model.Address”/>\n\n</ set >\n\n解释lazy、inverse、cascade以及all-delete-orphan属性的含义；并给出示例代码，说明在如下组合情况下，对于save、update、delete一对多关系中的一方对象操作时的区别：\n\ninverse\n\ncascade\n\ntrue\n\nall-delete-orphan\n\nfalse\n\nall-delete-orphan\n\ntrue\n\nall\n\nfalse\n\nall\n\ntrue\n\nnone\n\nfalse\n\nnone\n\n','解答：\n\n(一)lazy:延迟加载\n\nLazy的有效期：只有在session打开的时候才有效；session关闭后lazy就没效了。\n\nlazy策略可以用在：\n\nA、<class>标签上：可以取值true/false\n\nB、<property>标签上，可以取值true/false，这个特性需要类增强\n\nC、<set>/<list>等集合上，可以取值为true/false/extra\n\nD、<one-to-one>/<many-to-one>等标签上，可以取值false/proxy/no-proxy\n\n1) get和load的区别：\n\nA、get不支持延迟加载，而load支持。\n\nB、当查询特定的数据库中不存在的数据时，get会返回null，而load则抛出异常。\n\n2) 类(Class)的延迟加载：\n\nA、 设置<class>标签中的lazy=”true”,或是保持默认（即不配置lazy属性)\n\nB、 如果lazy的属性值为true，那么在使用load方法加载数据时，只有确实用到数据的时候才会发\n\n出sql语句；这样有可能减少系统的开销。\n\n3) 集合(collection)的延迟加载：可以取值true，false，extra\n\nA、true:默认取值，它的意思是只有在调用这个集合获取里面的元素对象时，才发出查询语句，加载其集合元素的数据\n\nB、false:取消懒加载特性，即在加载对象的同时，就发出第二条查询语句加载其关联集合的数据\n\nC、extra:一种比较聪明的懒加载策略，即调用集合的size/contains等方法的时候，hibernate并不会去加载整个集合的数据，而是发出一条聪明的SQL语句，以便获得需要的值，只有在真正需要用到这些集合元素对象数据的时候，才去发出查询语句加载所有对象的数据\n\n4) Hibernate单端关联懒加载策略：即在<one-to-one>/<many-to-one>标签上可以配置\n\n懒加载策略。可以取值为：false/proxy/no-proxy\n\nA、false:取消懒加载策略，即在加载对象的同时，发出查询语句，加载其关联对象\n\nB、proxy:这是hibernate对单端关联的默认懒加载策略，即只有在调用到其关联对象的方法的时候才真正发出查询语句查询其对象数据，其关联对象是代理类\n\nC、no-proxy:这种懒加载特性需要对类进行增强，使用no-proxy，其关联对象不是代理类\n\n注意：在class标签上配置的lazy属性不会影响到关联对象!!!\n\n（二）inverse\n\ninverse是指的关联关系的控制方向，inverse=false的side（side其实是指inverse＝false所位于的class元素）端有责任维护关系，而inverse＝true端无须维护这些关系\n\n（三）cascade\n\ncascade指的是层级之间的连锁操作。在定义关联对象的映射时，使用cascade=”all”，cascade=”save-update”,cascade=”all-delete-orphan”或cascade=”delete”\n\nA、如果父对象被保存，所有的子对象会被传递到saveOrUpdate()方法去执行(cascade=”save-update”)\n\nB、如果父对象被传递到update()或者saveOrUpdate()，所有的子对象会被传递到saveOrUpdate()方法去执行(cascade=”save-update”)\n\nC、如果一个临时的子对象被一个持久化的父对象引用了，它会被传递到saveOrUpdate()去执行 (cascade=”save-update”)\n\nD、如果父对象被删除了，所有的子对象对被传递到delete()方法执行 (cascade=”delete”)\n\ne.如果临时的子对象不再被持久化的父对象引用，什么都不会发生（必要时，程序应该明确的删除这个子对象），除非声明了cascade=”all-delete-orphan”，在这种情况下，成为“孤儿”的子对象会被\n\n删除。\n\n(四) save、update、delete一对多关系中的一方对象操作时的区别\n\n1）当一方设置inverse=true时，所有由一方发出的操作都不会关联到多方。\n\n2)当一方设置 inverse=false, cascade=all-delete-orphan时，将删除不再和一方对象关联的所有多方对象。\n\n3）当一方设置 inverse=false, cascade=all时,当保存和删除一方对象时，级联保存和删除所有关联的多方对象。\n\n4）当一方设置 inverse=false, cascade=none时,当对一方操作时，不级联到关联的多方对象。\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000478,'简单说明什么是递归？什么情况会使用？并使用java实现一个简单的递归程序。\n\n','解答：\n\n1）递归做为一种算法在程序设计语言中广泛应用.是指函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象。\n\n2）递归算法一般用于解决三类问题：\n\nA、数据的定义是按递归定义的。(Fibonacci（斐波那契）函数)\n\nB、问题解法按递归算法实现。(回溯)\n\nC、数据的结构形式是按递归定义的。(树的遍历，图的搜索)\n\n3）.这是一个排列的例子，它所做的工作是将输入的一个字符串中的所有元素进行排序并输出，例如：你给出的参数是”abc” 则程序会输出： abc acb bac bca cab cba A、算法的出口在于：ｌｏｗ＝ｈｉｇｈ也就是现在给出的排列元素只有一个时。 B、算法的逼近过程：先确定排列的第一位元素，也就是循环中ｉ所代表的元素， 然后ｌｏｗ＋１开始减少排列元素，如此下去，直到ｌｏｗ＝ｈｉｇｈ public class Foo {\n\npublic static void main(String[] args) {\n\npermute(“abc”);\n\n}\n\npublic static void permute(String str) {\n\nchar[] strArray = str.toCharArray();\n\npermute(strArray, 0, strArray.length – 1);\n\n}\n\npublic static void permute(char[] list, int low, int high) {\n\nint i;\n\nif (low == high) {\n\nString cout = “”;\n\nfor (i = 0; i <= high; i++)\n\ncout += list[i];\n\nSystem.out.println(cout);\n\n} else {\n\nfor (i = low; i <= high; i++) {\n\nchar temp = list[low];\n\nlist[low] = list[i];\n\nlist[i] = temp;\n\npermute(list, low + 1, high);\n\ntemp = list[low];\n\nlist[low] = list[i];\n\nlist[i] = temp;\n\n}\n\n}\n\n}\n\n}\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000479,'列出自己常用的jdk包.\n\n','解答：JDK常用的package\n\njavA、lang： 这个是系统的基础类，比如String等都是这里面的，这个package是唯一一个可以不用import就可以使用的Package\n\njavA、io: 这里面是所有输入输出有关的类，比如文件操作等\n\njavA、net: 这里面是与网络有关的类，比如URL,URLConnection等。\n\njavA、util : 这个是系统辅助类，特别是集合类Collection,List,Map等。\n\njavA、sql: 这个是数据库操作的类，Connection, Statememt，ResultSet等\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000480,'列出自己常用的jdk中的数据结构\n\n','解答：线性表，链表，哈希表是常用的数据结构。\n\n','4','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000481,'List、Map、Set三个接口存储元素时各有什么特点？\n\n','解答：\n\n1）List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。\n\n2）Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。\n\n3）Map接口 ：请注意，Map没有继承Collection接口，Map提供key到value的映射\n\n','2','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000482,'简述基于Struts框架Web应用的工作流程\n\n','解答：在web应用启动时就会加载初始化ActionServlet,ActionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象中， 当ActionServlet接收到一个客户请求时,将执行如下流程. 1)检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息; 2)如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中; 3)根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法; 4)如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActionErrors对象, 就表示表单验证成功; 5)ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的Action实例不存在,就先创建这个实例,然后调用Action的execute()方法; 6)Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给ActionForward对象指向的JSP组件; 7)ActionForward对象指向JSP组件生成动态网页,返回给客户;\n\n','1','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000483,' 在项目中用过Spring的哪些方面？及用过哪些Ajax框架？\n\n','解答：在项目使用过Spring IOC ，AOP，DAO，ORM，还有上下文环境。\n\n在项目使用过Ext,Juery等Ajax框架.\n\n','1','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000484,'abstract class和interface有什么区别?\n\n','解答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。接口（interface）是抽象类的变体。新型多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，所有成员变量都是public static final的。一个类可以实现多个接口，当类实现接口时，必须实现接口的所有方法。抽象类在Java语言中表示的是一种单继承的关系，对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。；抽象类中可以定义自己的成员变量，也可以包含非抽象的方法，而在接口中只能有静态的常量，所有方法必须是抽象的；实现抽象类时可以只实现其中的部分方法，而要是实现一个接口的话就必须实现这个接口中的所有抽象方法。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000485,'MVC模式中M，V，C每个代表意义，并简述在Struts中MVC的表现方式。\n\n','解答：\n\nMVC是Model-View-Controller 的缩写，Model代表的是应用的业务逻辑（通过JavaBean，EJB组件实现），View 是应用的表示层（由JSP页面产生）Controller是通过应用的处理过程控制，（一般是一个servert）通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现，这些组件可以进行交互和重用。\n\n在Struts框架中Controller功能由ActionServlet和ActionMapping对象构成，核心是一个Servlet类型的对象ActionServlet，它用来接收客户端的请求。ActionServlet包括一组基于配置的ActionMapping对象，每个ActionMapping对象实现了一个请求到一个具体的Model部分的Action处理器对象之间的映射。Model部分由Action和ActionForm对象构成。所有的Action处理器对象都是开发者从Struts的Action类派生的子类。Action处理器对象封装了具体的处理逻辑，调用业务逻辑模块，并且把响应提交到合适的View组件以产生响应。Struts提供的ActionForm组件对象可以通过定义属性描述客户端表单数据，开发者可以从它派生子类对象，并利用它和Struts提供的自定义标记库相结合，可以实现对客户端的表单数据的良好封装和支持，Action处理器对象可以直接对它进行读写，而不再需要和request、response对象进行数据交互。通过ActionForm组件对象实现了对View和Model之间交互的支持（View部分是通过JSP技术实现的）。Struts提供了自定义的标记库，通过这些自定义标记库可以非常容易地和系统的Model部分交互，通过使用这些自定义标记库创建的\n\nJSP表单，可以实现对Model部分中的ActionForm的映射，完成对用户数据的封装。\n\n','1','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000486,'java语言中public、private、protected三个关键字的用法,重写和重载的区别。\n\n','解答：\n\n作用域 当前类 同包 子类 其它\n\npublic √ √ √ √ protected √ √ √ × default √ √ × × private √ × × ×\n\n重写：发生在父子类之间，方法名相同，参数的类型、个数、顺序相同，返回值相同，访问权限不能更封闭，抛出异常不能宽泛；\n\n重载：发生在同一个类中，方法名相同，但是参数不同（类型不同或个数不同或参数的顺序不同），返回值可以不相同。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000487,'JSP页面之间传递参数的方法有哪些？\n\n','解答：\n\n1）request\n\n2）session\n\n3）application\n\n4）提交表单\n\n5）超链接\n\n','2','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000488,'forward 和redirect的区别\n\n','解答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，并且从浏览器的地址栏中可以看到跳转后的链接地址。前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接；在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。\n\n','2','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000489,'Java反射机制的作用？\n\n','解答：Java反射机制的作用是：\n\n1）在运行时判断任意一个对象所属的类。\n\n2）在运行时构造任意一个类的对象。\n\n3）在运行时判断任意一个类所具有的成员变量和方法。\n\n4）在运行时调用任意一个对象的方法\n\n','3','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000490,'你是怎么理解java的泛型的？\n\n','解答： 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。\n\n泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。\n\n泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。\n\n','3','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000491,'JAVA源文件中是否可以包括多个类,有什么限制\n\n','解答：一个java源文件中可以包含多个类，每个源文件中至多有一个public类，如果有的话，那么源文件的名字必须与之相同。如果源文件中没有public类，则源文件用什么名字都可以，但最好还是具有特定的意义，免得自己都不记得里面写的是什么了。\n\n','3','saq','前端',NULL,'2017-03-12 14:50:29',NULL),(00000000492,'在一个千万级的数据库查寻中，如何提高查询效率？分别说出在数据库设计、SQL语句、java等层面的解决方案。\n\n','解答：\n\n1）数据库设计方面：\n\nA、 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n\nB、 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0\n\nC、 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。\n\nD、 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n\ne. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。\n\nf. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。\n\ng. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n\nh. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。\n\ni. 避免频繁创建和删除临时表，以减少系统表资源的消耗。\n\nj. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。\n\nk. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。\n\nl. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。\n\n2)SQL语句方面：\n\nA、 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\n\nB、 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20\n\nC、 in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3\n\nD、 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’\n\ne. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num\n\nf. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2\n\ng. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’–name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0–‘2005-11-30’生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate>=’2005-11-30′ and createdate<’2005-12-1′\n\nh. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n\ni. 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…)\n\nj. 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=A、num)\n\nk. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。\n\nl. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。\n\nm. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n\nn. 尽量避免大事务操作，提高系统并发能力。\n\n3)java方面：\n\nA、尽可能的少造对象。\n\nB、合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。，\n\nC、使用jDBC链接数据库操作数据\n\nD、控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理；\n\ne.合理利用内存，有的数据要缓存\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000493,'请解释分布式事务管理？\n\n','解答：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。为了实现分布式事务，需要使用下面将介绍的两阶段提交协议。 阶段一：开始向事务涉及到的全部资源发送提交前信息。此时，事务涉及到的资源还有最后一次机会来异常结束事务。如果任意一个资源决定异常结束事务，则整个事务取消，不会进行资源的更新。否则，事务将正常执行，除非发生灾难性的失败。为了防止会发生灾难性的失败，所有资源的更新都会写入到日志中。这些日志是永久性的，因此，这些日志会幸免遇难并且在失败之后可以重新对所有资源进行更新。 阶段二：只在阶段一没有异常结束的时候才会发生。此时，所有能被定位和单独控制的资源管理器都将开始执行真正的数据更新。 在分布式事务两阶段提交协议中，有一个主事务管理器负责充当分布式事务协调器的角色。事务协调器负责整个事务并使之与网络中的其他事务管理器协同工作。 为了实现分布式事务，必须使用一种协议在分布式事务的各个参与者之间传递事务上下文信息，IIOP便是这种协议。这就要求不同开发商开发的事务参与者必须支持一种标准协议，才能实现分布式的事务。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000494,'请写出一段表单提交的HTML代码，表单名称为form1，提交方式为post，提交地址为submit.asp\n\n','解答：\n\n<form name=”form1” method=”post” action=”submit.jsp”>\n\n<input type=”submit”>\n\n</form\n\n43.请写出一个超链接，点击链接后可以向zhangsan@d-heaven.com发送电子邮件。\n\n<a href=”mailto: zhangsan@d-heaven.com”>发邮件</a>\n\n','2','saq','后台',NULL,'2017-03-12 14:50:29',NULL),(00000000495,'请说明meta标签的作用。\n\n','解答：\n\nmeta是用来在HTML文档中模拟HTTP协议的响应头报文。meta 标签用于网页的＜head＞与＜/head＞中，meta 标签的用处很多。meta 的属性有两种：name和http-equiv。name属性主要用于描述网页，对应于content（网页内容），以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）。这其中最重要的是description（站点在搜索引擎上的描述）和keywords（分类关键词），所以应该给每页加一个meta值。比较常用的有以下几个：\n\nname 属性\n\n1).＜meta name=”Generator” contect=”\"＞用以说明生成工具（如Microsoft FrontPage 4.0）等；\n\n2).＜meta name=”KEYWords” contect=”\"＞向搜索引擎说明你的网页的关键词；\n\n3).＜meta name=”DEscription” contect=”\"＞告诉搜索引擎你的站点的主要内容；\n\n4).＜meta name=”Author” contect=”你的姓名”＞告诉搜索引擎你的站点的制作的作者；\n\n5).＜meta name=”Robots” contect=\n\n“all|none|index|noindex|follow|nofollow”＞\n\n其中的属性说明如下：\n\n设定为all：文件将被检索，且页面上的链接可以被查询；\n\n设定为none：文件将不被检索，且页面上的链接不可以被查询；\n\n设定为index：文件将被检索；\n\n设定为follow：页面上的链接可以被查询；\n\n设定为noindex：文件将不被检索，但页面上的链接可以被查询；\n\n设定为nofollow：文件将不被检索，页面上的链接可以被查询。\n\n6).http-equiv属性\n\na、＜meta http-equiv=”Content-Type” contect=”text/html”;charset=gbk”＞\n\n和 ＜meta http-equiv=”Content-Language” contect=”zh-CN”＞用以说明主页制作所使用的文字以及语言；\n\nb、＜meta http-equiv=”Refresh” contect=”n;url=http://yourlink”＞定时让网页在指定的时间n内，跳转到页面http;//yourlink；\n\nc、＜meta http-equiv=”Expires” contect=”Mon,12 May 2001 00:20:00 GMT”＞可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式；\n\nd、＜meta http-equiv=”Pragma” contect=”no-cache”＞是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；\n\ne、＜meta http-equiv=”set-cookie” contect=”Mon,12 May 2001 00:20:00 GMT”＞cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；\n\nf、＜meta http-equiv=”Pics-label” contect=”\"＞网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的；\n\ng、＜meta http-equiv=”windows-Target” contect=”_top”＞强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；\n\nh、＜meta http-equiv=”Page-Enter” contect=”revealTrans(duration=10,transtion=\n\n50)”＞和＜meta http-equiv=”Page-Exit”\n\ncontect=”revealTrans(duration=20，transtion\n\n=6)”＞设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。\n\n','2','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000496,'请写出一个隐藏控件。\n\n','解答：<input type=”hidden” name=”userId” value=”10001”>\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:29',NULL),(00000000497,'如何将HTML页面的标题设置为“数字天堂”。\n\n','解答：\n\n<html>\n\n<head><title>数字天堂</title></head>\n\n<body>body部分</body>\n\n</html>\n\n','2','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000498,'请写出JavaScript中常用的三种事件。\n\n','解答： onclick，onblur，onChange\n\n','3','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000499,'请写出一段JavaScript代码，要求页面有一个按钮，点击按钮弹出确认框。程序可以判断出用\n\n户点击的是“确认”还是“取消”。\n\n','解答：\n\n<HTML>\n\n<HEAD>\n\n<TITLE>click</TITLE>\n\n<Script >\n\nfunction validateForm()\n\n{\n\nif(confirm(“你确认提交这个表单么？”))\n\n{\n\nalert(“确定”);\n\n}else{\n\nalert(“取消”);\n\n}\n\n}\n\n</Script>\n\n</HEAD>\n\n<BODY>\n\n<FORM NAME=”TEST” action=”FirstJS.htm”>\n\n<INPUT TYPE=”button” NAME=”SUB” VALUE=”提交”onClick=”JavaScript:validateForm()”>\n\n</FORM>\n\n</BODY>\n\n</HTML>\n\n49.JavaScript如何实现计时功能。\n\n解答：<script> window.setTimeout( “window.location = ‘http://www.csdn.net ‘; “, 35000); </script>\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000500,'JavaScript如何定义数组。\n\n','解答： var arrTest=new Array();\n\n','2','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000501,'JavaScript能否操作cookie和session？\n\n','解答：JavaScript可以操作cookie，但是不能操作session\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000502,'请写出如下正则表达式的含义；\n\ncom︱cn︱net\n\n^http://www.d-heaven.com/$\n\n^http://www.sinA、com.cn/new/newid=\\d+\n\n','解答：com︱cn︱net表示匹配com或是cn或是net中一个\n\n^http://www.d-heaven.com/$ 表示匹配：http://www.d-heaven.com/\n\n^http://www.sinA、com.cn/new/newid=\\d+\n\n表示匹配http://www.sinA、com.cn/new/newid=其后可以出现1到多个数字\n\n','2','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000503,'请用正则表达式匹配出QQ号（假设QQ号码为5—10位）；\n\n','解答： ^ \\d{5,10}$\n\n54. #!String, StringBuffer StringBuilder的区别。 解答：String的长度是不可变的； StringBuffer的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法；线程安全； StringBuilder是从 JDK 5 开始，为StringBuffer该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000504,'请写出5种常见到的runtime exception。\n\n','解答：\n\nNullPointerException：当操作一个空引用时会出现此错误。\n\nNumberFormatException：数据格式转换出现问题时出现此异常。\n\nClassCastException：强制类型转换类型不匹配时出现此异常。\n\nArrayIndexOutOfBoundsException：数组下标越界，当使用一个不存在的数组下标时出现此异常。\n\nArithmeticException：数学运行错误时出现此异常\n\n','5','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000505,'数组有没有length()这个方法？String有没有length()这个方法？\n\n','解答：数组没有length（）方法 它有length属性\n\nString有length（）方法。\n\n','5','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000506,'请写出一个单例模式。\n\n','解答：单例模式（Singleton pattern）:确保一个类只有一个实例，并提供一个全局的访问点\n\npublic class EagerSingleton { private static final EagerSingleton m_instance = new EagerSingleton(); /** * 私有的默认构造子 */ private EagerSingleton() { } /** * 静态工厂方法 */ public static EagerSingleton getInstance() { return m_instance; } }\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000507,'在java中，List是个接口，那实现List接口的类有哪些，有什么区别？\n\n','解答： ArrayList是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，\n\nLinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000508,'char类型能否存储一个中文字符？为什么\n\n','解答：可以。一个char是两个字节，而一个中文也是两个字节。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000509,'Switch选择语句能否作用在String【字符串】上，也就是能否这么写：Switch(一个字符串变量)？\n\n','解答：不可以，只能处理int,byte,short,char，（其实是只能处理int,其它三种是可以promotion到int型）不能处理Sring 。\n\n','4','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000510,'关键字final 分别修饰一个类，一个方法，一个变量，各起什么作用\n\n','解答：final修饰类是不能被继承\n\nfianl修饰方法不能在子类中被覆盖\n\nfinal修饰变量，称为常量，初始化以后不能改变值。\n\n','1','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000511,'启动一个线程是用run()还是start()?\n\n','解答：start（）。\n\n','4','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000512,'是否可以继承String类\n\n','解答：不可以。因为String类有final修饰。\n\n','3','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000513,'Java异常处理中，try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?\n\n','解答：会执行，在return前执行。\n\n','2','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000514,'EJB包含哪3种bean\n\n','解答：session bean（会话bean）, entity bean（实体bean）, message bean（消息bean）\n\n','5','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000515,'Class.forName（String className）这个方法的作用\n\n','解答：通过类的全名获得该类的类对象\n\n','1','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000516,'你认为在表上建立索引可以提高数据库系统的效率吗，为什么？\n\n','解答：不一定\n\n建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where子句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000517,'hibernate中的java对象有几种状态，其相互关系如何（区别和相互转换）。\n\n','解答：在Hibernate中，对象有三种状态：临时状态、持久状态和游离状态。 临时状态：当new一个实体对象后，这个对象处于临时状态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被jre垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save或者SaveOrUpdate把临时对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久对象；\n\n持久状态:持久化对象的实例在数据库中有对应的记录，并拥有一个持久化表示（ID）。对持久化对象进行delete操作后，数据库中对应的记录将被删除，那么持久化对象与数据库记录不再存在对应关系，持久化对象变成临时状态。\n\n持久化对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。在同步之前，持久化对象是脏的（Dirty）。\n\n游离状态：当Session进行了Close、Clear或者evict后，持久化对象虽然拥有持久化标识符和与数据库对应记录一致的值，但是因为会话已经消失，对象不在持久化管理之内，所以处于游离状态（也\n\n叫：脱管状态）。游离状态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。\n\n','1','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000518,'对hibernate的延迟加载如何理解，在实际应用中，延迟加载与session关闭的矛盾是如何处理的？\n\n','解答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。那么Hibernate是怎么知识用户在什么时候使用数据了呢？又是如何加载数据呢？其实很简单，它使用了代理机制。返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时就会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。这种情况就叫做未初始化的关系。\n\n延迟加载与session关闭的矛盾一般可以这样处理：\n\n1)、关闭延迟加载特性。\n\n操作起来比较简单，因为hibernate的延迟加载特性是在hbm配置里面可控制的。默认lazy=”true”，具体配置可以查看一下相关文档，就不详细叙述了。\n\n但使用这个解决办法带来的隐患是十分大的。\n\n首先，出现no session or session was closed就证明了您已经在使用外键关联表，如果去掉延迟加载的话，则表示每次查询的开销都会变得十分的大，如果关联表越多，后果也可以想象得到。所以不建议使用这个方法解决。\n\n2)、在session关闭之前把我们想要查询的数据先获取了。\n\n首先需要了解一下session什么时候关闭，也就是它的生命周期。通常情况下hibernate会在查询数据关闭session，而使用getHibernateTemplate().get方法查询后会延迟关闭的时间。会在事务结束后才关闭。\n\n使用拦截器(Interceptor)或过滤器(Filter)控制session。\n\nspring为解决hibernate这一特性提供的解决方案，可以有效的控制session生命周期。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000519,'什么是AOP和OOP，IOC和DI有什么不同?\n\n','解答：\n\n1）面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。AOP是OOP的延续，是Aspect Oriented Programming的缩写，意思是面向方面编程。 将通用需求功能从不相关类之中分离出来；同时，能够使得很多类共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这个行为就可以。AOP就是这种实现分散关注的编程方法，它将“关注”封装在“方面”中\n\n2）控制反转IOC(Inversion of Control) 控制指的就是程序相关类之间的依赖关系.传统观念设计中,\n\n通常由调用者来创建被调用者的实例, 在Spring里,创建被调用者的工作不再由调用者来完成,而是由Spring容器完成，依赖关系被反转了，称为控制反转，目的是为了获得更好的扩展性和良好的可维护性。依赖注入(Dependency injection)创建被调用者的工作由Spring容器完成，然后注入调用者，因此也称依赖注入。控制反转和依赖注入是同一个概念。\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000520,'Struts1中actionform和action属于MVC哪一层，为什么？\n\n','解答：actionform和action属于MVC的Model层，Action用来处理业务逻辑，actionform保存用户表单数据以便于在不同页面间传递。而MVC中的model层就是业务逻辑层，该层用于实现具体的业务逻辑、状态维护及管理。\n\n','5','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000521,'error和exception有什么区别?\n\n','解答：\n\nerror表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况； exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。\n\n','5','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000522,'Log4J是Apache组织的开源一个开源项目，通过Log4J，可以指定日志信息输出的目的地，如console、file等。Log4J采用日志级别机制，请按照输出级别由低到高的顺序写出日志输出级别。\n\n','解答：Log4J分 为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别， 则应用程序中所有DEBUG级别的日志信息将不被打印出来。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000523,'说出几个与spring同类型的开源框架，说出几个与hibernate同类型的开源框架,说出几个与struts同类型的开源框架\n\n','解答：\n\n1）与spring同类型的开源框架：JUIDE、EJB3.0、picoContainer\n\n2）与hibernate同类型的开源框架 ：ibatis，jdo，JPA\n\n3）几个与struts同类型的开源框架：webwork，tapestry，JSF\n\n','3','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000524,'Struts2包含哪些标签？\n\n','解答：\n\nA：\n\n<s:a href=”\"></s:a>—–超链接，类似于html里的<a></a>\n\n<s:action name=”\"></s:action>—–执行一个view里面的一个action <s:actionerror/>—–如果action的errors有值那么显示出来 <s:actionmessage/>—–如果action的message有值那么显示出来 <s:append></s:append>—–添加一个值到list，类似于list.add(); <s:autocompleter></s:autocompleter>—–自动完成<s:combobox>标签的内容，这个是ajax\n\nB： <s:bean name=”\"></s:bean>—–类似于struts1.x中的，JavaBean的值\n\nC： <s:checkbox></s:checkbox>—–复选框 <s:checkboxlist list=”\"></s:checkboxlist>—–多选框 <s:combobox list=”\"></s:combobox>—–下拉框 <s:component></s:component>—–图像符号\n\nD： <s:date/>—–获取日期格式 <s:datetimepicker></s:datetimepicker>—–日期输入框 <s:debug></s:debug>—–显示错误信息 <s:div></s:div>—–表示一个块，类似于html的<div></div> <s:doubleselect list=”\" doubleName=”\" doubleList=”\"></s:doubleselect>—–双下拉框\n\nE： <s:if test=”\"></s:if> <s:elseif test=”\"></s:elseif> <s:else></s:else>—–这3个标签一起使用，表示条件判断\n\nF： <s:fielderror></s:fielderror>—–显示文件错误信息 <s:file></s:file>—–文件上传 <s:form action=”\"></s:form>—–获取相应form的值\n\nG： <s:generator separator=”\" val=”\"></s:generator>—-和<s:iterator>标签一起使用\n\nH： <s:head/>—–在<head></head>里使用，表示头文件结束\n\n<s:hidden></s:hidden>—–隐藏值\n\nI： <s:i18n name=”\"></s:i18n>—–加载资源包到值堆栈 <s:include value=”\"></s:include>—–包含一个输出，servlet或jsp页面 <s:inputtransferselect list=”\"></s:inputtransferselect>—–获取form的一个输入 <s:iterator></s:iterator>—–用于遍历集合\n\nL： <s:label></s:label>—–只读的标签\n\nM： <s:merge></s:merge>—–合并遍历集合出来的值\n\nO： <s:optgroup></s:optgroup>—–获取标签组 <s:optiontransferselect doubleList=”\" list=”\" doubleName=”\"></s:optiontransferselect>—–左右选择框\n\nP： <s:param></s:param>—–为其他标签提供参数 <s:password></s:password>—–密码输入框 <s:property/>—–得到’value’的属性 <s:push value=”\"></s:push>—–value的值push到栈中,从而使property标签的能够获取value的属性\n\nR：\n\n<s:radio list=”\"></s:radio>—–单选按钮 <s:reset></s:reset>—–重置按钮 S： <s:select list=”\"></s:select>—–单选框 <s:set name=”\"></s:set>—–赋予变量一个特定范围内的值 <s:sort comparator=”\"></s:sort>—–通过属性给list分类 <s:submit></s:submit>—–提交按钮 <s:subset></s:subset>—–为遍历集合输出子集\n\nT：\n\n<s:tabbedPanel id=”\"></s:tabbedPanel>—–表格框 <s:table></s:table>—–表格 <s:text name=”\"></s:text>—–I18n文本信息 <s:textarea></s:textarea>—–文本域输入框 <s:textfield></s:textfield>—–文本输入框 <s:token></s:token>—–拦截器 <s:tree></s:tree>—–树 <s:treenode label=”\"></s:treenode>—–树的结构\n\nU： <s:updownselect list=”\"></s:updownselect>—–多选择框 <s:url></s:url>—–创建url\n\n','1','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000525,'struts2中，OGNL访问值栈的时候查找的顺序是什么？请排序：模型对象、临时对象、固定名称的对象、Action对象\n\n','解答：struts2的值栈排列顺序为：1）.临时对象；2）.模型对象；3）.Action对象；4）.固定名称对象（如#application, #session, #request等对象）。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000526,'struts2中，Action通过什么方式获得用户从页面输入的数据，又是通过什么方式把其自身的数据传给视图的？\n\n','解答：\n\n1）可以直接通过与表单元素相同名称的数据成员（需要存在符合命名规范set和get方法）获取页面表单数据。\n\n2）会把处理好的数据成员放入值栈中，到页面可以使用struts2标签取值就可以了。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000527,'常用的设计模式有哪些？说明工厂模式。\n\n','解答：Java中的23种设计模式：\n\nFactory（工厂模式）， Builder（建造模式），Factory Method（工厂方法模式），\n\nPrototype（原始模型模式），Singleton（单例模式）,Facade（门面模式），\n\nAdapter（适配器模式），Bridge（桥梁模式）,Composite（合成模式），\n\nDecorator（装饰模式），Flyweight（享元模式），Proxy（代理模式），\n\nCommand（命令模式），Interpreter（解释器模式），Visitor（访问者模式），\n\nIterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），\n\nObserver（观察者模式），State（状态模式），Strategy（策略模式），\n\nTemplate Method（模板方法模式）， Chain Of Responsibleity（责任链模式）\n\n工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。\n\n','5','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000528,'什么是数据库的参照完整性？\n\n','解答：数据库的参照完整性是指表与表之间的一种对应关系，通常情况下可以通过设置两表之间的主键、外键关系，或者编写两表的触发器来实现。 有对应参照完整性的两张表格，在对他们进行数据插入、更新、删除的过程中，系统都会将被修改表格与另一张对应表格进行对照，从而阻止一些不正确的数据的操作。\n\n','1','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000529,'如何优化数据库，如何提高数据库的性能?\n\n','解答：\n\n1） 硬件调整性能 最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。\n\n2）调整数据库\n\n若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。\n\n3）使用存储过程\n\n应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。\n\n4）应用程序结构和算法\n\n建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在\n\n使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000530,'JS中的三种弹出式消息提醒(警告窗口、确认窗口、信息输入窗口)的命令是什么？\n\n','解答：alert confirm prompt\n\n','5','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000531,'描述JSP和Servlet的区别、共同点、各自应用的范围\n\n','解答：JSP在本质上就是SERVLET,但是两者的创建方式不一样.Servlet完全是JAVA程序代码构成，擅长于流程控制和事务处理，通过Servlet来生成动态网页很不直观.JSP由HTML代码和JSP标签构成，可以方便地编写动态网页.因此在实际应用中采用Servlet来控制业务流程，而采用JSP来生成动态网页.\n\n','5','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000532,'在java语言中int 和 Integer 有什么区别\n\n','解答：int是基本数据类型，Integer是int的包装类，属于引用类型\n\n','5','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000533,'计算下列结果：\n\n25&3 =\n\n25|3=\n\n','解答：25的二进制是11001 ， 3的二进制是00011， 按位与的结果是：00001 ，按位或的结果是：11010，因此转成10进制分别为：1 和27\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:30',NULL),(00000000534,'如何获得<div id=”div1”>This is first layer</div>中的值？\n\n','解答：\n\n<script>\n\nvar div1=Document.getElementById(“div1”);\n\nalert(div1.innerHTML)\n\n</script>\n\n','2','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000535,'JDK1.5中支持的 for循环的语法\n\n','解答：\n\nfor(type element : array) { System.out.println(element)\n\n} type 集合(不仅仅指Collection，也包含普通的数组)中元素的数据类型 element 遍历到的元素 array 集合对象本身(当然不只是Collection)\n\n','3','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000536,'简述synchronized和javA、util.concurrent.locks.Lock的异同？\n\n','解答：\n\n主要相同点：Lock能完成synchronized所实现的所有功能 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。\n\n','5','saq','后台',NULL,'2017-03-12 14:50:30',NULL),(00000000537,'如何格式化日期\n\n','解答：\n\nDate now=new Date();\n\nSimpleDateFormat sdf=new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);\n\nString formatNow=sdf.format(now);\n\n变量formatNow就是格式化好的日期。\n\n','3','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000538,'将字符“12345”转换成long型\n\n','解答： String s=”12345″;\n\nlong num=Long.valueOf(s).longValue();\n\n','3','saq','前端',NULL,'2017-03-12 14:50:30',NULL),(00000000539,'struts中如何实现国际化，涉及哪些文件？\n\n','解答：“国际化”是指一个应用程序在运行时能够根据客户端请求所来自的国家/地区、语言的不同而显示不同的用户界面。Struts框架通过使用<bean:message>标记，以及使用javA、util数据包中定义的Locale和ResourceBundle类来支持国际化。javA、text.MessageFormat类定义的技术可以支持消息的格式。利用此功能，开发人员不需了解这些类的细节就可进行国际化和设置消息的格式。会涉及到资源文件，不需了解这些类的细节就可进行国际化和设置消息的格式。会涉及到资源文件，struts-config.xml配置文件,weB、xml配置文件。\n\n','4','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000540,'例举在诊断Oracle性能问题时，常用的工具、方法\n\n','解答： 1）简单一点的可以用toad及dbartisan这样的工具。 2）纯做性能监测，比较出色的有spolight和emc的I3，这两个软件都比较贵。 3）一些网管系统这方面也不错，如hp的openview。不过定制起来不太容易，且很贵。\n\n4）不用花钱又好用的就是Oracle的statpack了。 5）再有就是自己写脚本了，大多数有经验的DBA都喜欢这样的方式。优点是实用灵活。缺点是如果想出一个性能变化的曲线图等图表，且做的美观就需要些delphi,c++builder或是pb的开发功底了。\n\n','1','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000541,'Oracle启动中，startup nomount、 startup mount 有什么差别？\n\n','解答： startup nomount：启动实例，读取参数文件，分配内存空间，启动后台进程，打开跟踪文件和报警文件。startup mount：装载数据库，打开控制文件。nomount方式下还没有读取控制文件，该选项用于在数据库的控制文件全部损坏，需要重新创建数据库控制文件或创建一个新的数据库时使用。mount 选项下并没有打开数据文件，该选项可以用来修改数据库的运行模式或进行数据库恢复。\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000542,'Oracle启动中，spfile.ora、init<SID>.ora、spfile<SID>.ora 这三个文件正确的先后顺序是什么？\n\n','解答：启动数据库，使用startup命令，Oralce将会按照以下顺序在缺省目录中搜索参数文件：spfile<SID>.ora , spfile.ora ,init<SID>.ora a\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000543,'说明Oracle数据库逻辑备份和物理备份的方式。\n\n','解答：Oracle备份包括逻辑备份和物理备份。\n\n1）.逻辑备份\n\n数据库的逻辑备份包含读一个数据库记录集和将记录集写入文件。\n\nA、输出（Export）输出可以是整个数据库、指定用户或指定表。\n\nB、输入（Import）输入将输出建立的二进制转储文件读入并执行其命令。\n\n2).物理备份\n\n物理备份包含拷贝构成数据库的文件而不管其逻辑内容。\n\nOracle支持两种不同类型的物理文件备份：脱机备份（offline backup）和联机备份（online backup）。\n\nA、脱机备份: 脱机备份用在当数据库已正常关闭，数据库处于”offline”时，要备份下列文件：\n\n所有数据文件\n\n所有控制文件\n\n所有联机日志\n\ninit.ora（可选的）\n\nb 联机备份:联机备份可用来备份任何运作在ARCHIVELOG方式下的数据库。在这种方式下，联机日志被归档，在数据库内部建立一个所有作业的完整记录。联机备份过程具备强有力的功能。第一，提供了完全的时间点（point-in-time）恢复。第二，在文件系统备份时允许数据库保持打开状态。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000544,'有2个类Cat及WhiteCat，代码如下：\n\npublic class Cat {\n\nprotected static String color = “random”;\n\npublic Cat() {\n\n}\n\npublic void showCatColor() {\n\nSystem.out.println(“Cat:” + color);\n\n}\n\npublic static void showColor() {\n\nSystem.out.println(“Cat:” + color);\n\n}\n\n}\n\npublic class WhiteCat extends Cat {\n\nprotected static String color = “white”;\n\npublic WhiteCat() {\n\nsuper();\n\n}\n\npublic void showCatColor() {\n\nSystem.out.println(“WhiteCat:” + color);\n\n}\n\npublic static void showColor() {\n\nSystem.out.println(“WhiteCat:” + color);\n\n}\n\n}\n\n请分析下面各段程序的运行结果\n\nA、WhiteCat whiteCat = new WhiteCat(); Cat cat = whiteCat; cat.showColor(); cat.showCatColor();\n\nB、Cat cat = new Cat(); WhiteCat whiteCat = (WhiteCat) cat;\n\ncat.showColor(); cat.showCatColor();\n\nC、Cat cat = new WhiteCat(); WhiteCat whiteCat = (WhiteCat) cat; cat.showColor(); cat.showCatColor();\n\n','解答：A段执行的结果是：\n\nCat:random\n\nWhiteCat:white\n\nB段执行的结果是：\n\n会抛出javA、lang.ClassCastException异常\n\nC段执行的结果是：\n\nCat:random\n\nWhiteCat:white\n\n','2','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000545,'说说下面语句是否有错误，或可能出现的缺陷，并指出错误，或缺陷在哪里？\n\npublic class MyFile implements Runnable{\n\npublic void run(){\n\nwhile (true){\n\ntry{\n\nFileReader fr=new FileReader(new File(“A、txt”)) ;\n\nString line=fr.readLine();\n\nSystem.out.println(line);\n\n}catch(IOException err) {\n\n}\n\nSleep(1000); }\n\n}\n\n','解答： 1.fr.readLine()没有这个方法\n\n2.Sleep(1000)需要用ThreaD、sleep(1000);\n\n','4','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000546,'判断下列语句是否正确，如果有错误，请指出错误所在？\n\nList<Short> a = new ArrayList<Short>();\n\na.add(5);\n\n','解答：错误,默认封装int类型。\n\n','3','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000547,'判断下列语句是否正确，如果有错误，请指出错误所在？\n\nvoid foo(final int []arg){\n\nif (arg.length > 1)\n\narg[0] = 5;\n\n}\n\n','解答：正确\n\n','2','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000548,'判断下列语句是否正确，如果有错误，请指出错误所在？\n\ninterface A{\n\nint add(final A a);\n\n}\n\nclass B implements A{\n\nlong add(final A a){\n\nreturn this.hashCode() + A、hashCode();\n\n}\n\n}\n\n','解答：返回值不是long类型\n\n','5','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000549,'指出下面程序的运行结果：\n\nclass A{\n\nstatic{\n\nSystem.out.print(“a”);\n\n}\n\npublic A (){\n\nSystem.out.print(“x”);\n\n}\n\n}\n\nclass B extends A{\n\nstatic{\n\nSystem.out.print(“b”);\n\n}\n\npublic B (){\n\nSystem.out.print(“y”);\n\n}\n\n}\n\npublic class Test{\n\npublic static void main(String[] args){\n\nA ab = new B ();\n\nab = new B ();\n\n}\n\n}\n\n','解答：abxyxy\n\n','1','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000550,'下列代码的输出结果是什么？\n\npublic class MyFor {\n\npublic static void main (String argv[]){\n\nint i; int j;\n\nouter:for(i=1;i<3;i++)\n\ninner:for(j=1;j<3;j++){\n\nif (j==2) continue outer;\n\nSystem.out .println(“Value for i=”+i+” Value for j=” +j);\n\n}\n\n}\n\n}\n\n','解答：Value for i=1 Value for j=1\n\nValue for i=2 Value for j=1\n\n','2','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000551,'查看下面的代码，写出可以使程序正常执行的修改方法\n\n1.public class MyClass {\n\n2.static String s1;\n\n3. String s2;\n\n4. public static void main(String args[]) {\n\n5. String s3;\n\n6. System.out.println(“s1 =” + s1);\n\n7. System.out.println(“s2 =” + s2);\n\n8. System.out.println(“s3 =” + s3);\n\n9. }\n\n10.}\n\n','解答：删除第8行或者将第6行改为String s3 = “”;\n\n','3','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000552,'为了显示myStr = 23 这样的结果，写出在控制台输入的命令\n\npublic class MyClass {\n\npublic static void main(String args[]) {\n\nString s1 = args[0];\n\nString s2 = args[1];\n\nString myStr = args[2];\n\nSystem.out.printin(“myStr =” + s2 + myStr);\n\n}\n\n}\n\n','解答：java MyClass 1 2 3 4\n\n','4','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000553,'写出下面代码的执行结果\n\npublic class MyClass {\n\nstatic void aMethod(StringBuffer sf1, StringBuffer sf2) {\n\nsf1.append(sf2);\n\nsf2 = sf1;\n\n}\n\npublic static void main(String[] args){\n\nStringBuffer sf1 = new StringBuffer(“A”);\n\nStringBuffer sf2 = new StringBuffer(“B”);\n\naMethod(sf1,sf2);\n\nSystem.out .println(sf1+ “:”+sf2);\n\n}\n\n}\n\n','解答：AB:B\n\n','1','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000554,'第3行中生成的object在第几行执行后成为garbage collection的对象？\n\n1.public class MyClass {\n\n2. public StringBuffer aMethod() {\n\n3. StringBuffer sf = new StringBuffer(“Hello”);\n\n4. StringBuffer[] sf_arr = new StringBuffer[1];\n\n5. sf_arr[0] = sf;\n\n6. sf = null;\n\n7. sf_arr[0] = null;\n\n8. return sf;\n\n9. }\n\n10.}\n\n','解答：第7行\n\n','5','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000555,'写出执行下面的代码后的结果\n\npublic class MyClass {\n\npublic static void main(String args[]) {\n\njavA、util.Vector v1 = new javA、util.Vector();\n\nv1.addElement(“Hello”);\n\nv1.addElement(new Float(3.14f));\n\nv1.addElement(10);\n\nSystem.out.println(v1.elementAt(0) + “:” + v1.elementAt(1) + “:”+ v1.elementAt(2));\n\n}\n\n}\n\n','解答：Hello : 3.14 : 10\n\n','2','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000556,'写出执行下面代码后的正确结果\n\ninterface MyDB {\n\npublic void getConnection();\n\n}\n\nclass MyDBDriver implements MyDB {\n\npublic void getConnection() {\n\nSystem.out.println(“getConnection()”);\n\n}\n\n}\n\npublic class MyClass {\n\npublic static void aMethod(MyDB db) {\n\ndB、getConnection();\n\n}\n\npublic static void main(String args[]) {\n\nMyDBDriver db_driver = new MyDBDriver();\n\naMethod(db_driver);\n\n}\n\n}\n\n','解答：getConnection()\n\n','4','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000557,'下列程序运行的结果是\n\nclass A {\n\nclass Dog {\n\nprivate String name;\n\nprivate int age;\n\nprivate int step;\n\nDog(String s, int a) {\n\nname = s;\n\nage = a;\n\nstep = 0;\n\n}\n\npublic void run(Dog fast) {\n\nfast.step++;\n\n}\n\n}\n\npublic static void main(String args[]) {\n\nA a = new A();\n\nDog d = A、new Dog(“Tom”, 3);\n\nD、step = 25;\n\nD、run(d);\n\nSystem.out.println(D、step);\n\n}\n\n}\n\n','解答：26\n\n','1','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000558,'请看下列程序，运行结果是\n\nclass Super{\n\nint i=10;\n\nSuper(){\n\nprint();\n\ni=20;\n\n}\n\nvoid print(){\n\nSystem.out.print(i);\n\n}\n\n}\n\npublic class Sub extends Super{\n\nint j=30;\n\nSub(){\n\nprint();\n\nj=40;\n\n}\n\nvoid print(){\n\nSystem.out.print(j);\n\n}\n\npublic static void main(String[] args){\n\nSystem.out.print(new Sub().j);\n\n}\n\n}\n\n','解答：03040\n\n','1','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000559,'getSomething ()执行时发生IllegalArgumentException会出现什么样的结果？\n\nvoid makeConnection(String url) {\n\ntry {\n\ngetSomething();\n\n}catch(NullPointerException e) {\n\nSystem.out.printin(“Invalid URL”) ;\n\nreturn;\n\n}catch(Exception e) {\n\nSystem.out.println(“Exception”);\n\n}\n\n}\n\n','解答：Exception\n\n','4','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000560,'Tomcat服务器的默认端口是多少？怎样修改tomcat的端口？\n\n','解答：默认端口为8080，可以通过service.xml的Connector元素的port属性来修改端口。\n\n','3','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000561,'多线程有几种实现方法,都是什么?同步的方法有几种，都是什么？\n\n','解答：多线程有两种实现方法：继承Thread类或者实现Runnable接口。\n\n实现同步也有两种方法：一种是同步方法，另一种是同步代码块。\n\n同步方法是在方法返回类型前面加上synchronized关键字\n\n同步代码块是synchronized (这里写需要同步的对象){…}\n\n','1','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000562,'谈一下聚簇索引和非聚簇索引的区别以及各自的优缺点。\n\n','解答：\n\n聚集索引,表中存储的数据按照索引的顺序存储,检索效率比普通索引高,但对数据新增/修改/删除的影响比较大 非聚集索引,不影响表中的数据存储顺序,检索效率比聚集索引低,对数据新增/修改/删除的影响很小\n\n114.#!死锁的必要条件？怎么克服？\n\n解答：产生死锁的四个必要条件：\n\n互斥条件：一个资源每次只能被一个进程使用。\n\n请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n\n不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。\n\n循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。\n\n死锁的解决方法:\n\na 撤消陷于死锁的全部进程； b逐个撤消陷于死锁的进程，直到死锁不存在； c从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。 d从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态\n\n','4','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000563,'描述重做与回滚的认识;\n\n','解答：重做日志生成日志文件,是为将来恢复数据库使用的.\n\n回滚段保存未提交数据,是为支持事务而起作用的。\n\n','2','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000564,'索引组织表,聚蔟表的用途;\n\n','解答：\n\n索引组织表：数据按主码存储和排序，同索引结构一样，不过数据直接存储于主码后面。适用于信息.检索、空间和OLAP程序。索引组织表的适用情况：\n\nA、代码查找表。\n\nB、经常通过主码访问的表。\n\nC、构建自己的索引结构。\n\nD、加强数据的共同定位，要数据按特定顺序物理存储。\n\ne.经常用between„and„对主码或唯一码进行查询。数据物理上分类查询。如一张订单表，按日期装载数据，想查单个客户不同时期的订货和统计情况。\n\n索引聚簇表：索引聚簇表是表相关的表共享同一数据块中的相同列，并把相关数据存储中同一个数据块上。创建索引聚簇表中最重要的是对SIZE参数有很好的估量，否则聚簇将会降低空间利用，降低效率。\n\n使用索引聚簇表的注意点：\n\na如果表中数据有大量DML操作的话，那么聚簇将不适用，因为会消极地影响到DML性能。\n\nb聚簇中，全表扫描将受到影响。这是因为将扫描聚簇中不同表的数据，额外增加很多无用的数据。\n\nc如果经常TRUNCATE表和装载表的话，聚簇将不适用。聚簇中的表无法被TRUNCATE的，这是因为每个块中不只是存储一张表的数据。\n\nSQL> truncate table emp;\n\ntruncate table emp\n\n*\n\nERROR at line 1:\n\nORA-03292: Table to be truncated is part of a cluster\n\nd如果大部分是读取操作，且通过聚簇码索引或聚簇表中其他索引来读取的话，聚簇将会比较适用。\n\n','5','saq','Java语法',NULL,'2017-03-12 14:50:31',NULL),(00000000565,'消耗资源的SQL的定位方法;\n\n','解答：select sql_text from v$sql where disk_reads > 1000 or (executions > 0 and buffer_gets/executions > 30000);\n\nSELECT * FROM ( SELECT sql_text,buffer_gets,disk_reads FROM v$sql ORDER BY buffer_gets,disk_reads DESC) WHERE ROWNUM<=10;\n\n','5','saq','前端',NULL,'2017-03-12 14:50:31',NULL),(00000000566,'对触发器的认识;\n\n','解答：触发器是表上的程序,主要提供数据添加、修改与删除后的程序处理方法，可以用来检查数据及进行数据更新，也可以分担一些前端应用程序撰写的逻辑规则。用场景: 触发器可以查询其他表，而且可以包含复杂的SQL语句。它们主要用于强制复杂的业务规则或要求。\n\n触发器的主要应用场合概括起来讲有以下几种：\n\n1).当向一张表中添加或删除记录时，需要在相关表中进行同步操作。比如，当为应用系统添加一个系统用户时，需要同时向权限表中添加该用户的缺省权限，此时就编写系统用户表的触发器在添加记录动作时触发。\n\n2).当表上某列数据的值与其他表中的数据有联系时。比如，当某客户进行欠款消费，可以在生成订单时通过设计触发器判断该客户的累计欠款是否超出了最大限度。\n\n3).当需要对某张表进行跟踪时。比如，当人事表中有人离职时，第一时间通知或更改相关表的值。\n\n','4','saq','后台',NULL,'2017-03-12 14:50:31',NULL),(00000000567,'121#!EJB的优点有哪些？(选择2项)\n\n\n\nA、技术领先 B、价格低廉 C、性能优越 D、强大的容器支持\n\n\n\n','解答：CD\n\n\n\n','4','chose','Java语法',NULL,'2017-03-12 14:55:46',NULL),(00000000568,'以下哪些接口能够实现对Web访问者的身份认证？(选择1项)\n\n\n\nA、Http Servlet Request\n\n\n\nB、Http Servlet Response\n\n\n\nC、Http Session\n\n\n\nD、Http Servlet\n\n\n\n','解答：C\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:46',NULL),(00000000569,'无状态会话Bean、有状态会话Bean、CMP与BMP中，哪一种Bean不需要自己书写连接数据库的代码？\n\n\n\nA、无状态会话Bean\n\n\n\nB、有状态会话Bean\n\n\n\nC、CMP\n\n\n\nD、BMP\n\n\n\n','解答：C\n\n\n\nBMP是在Bean中完成对数据库JDBC的各种调用\n\n\n\nCMP是由EJB容器自动完成对数据库的操作\n\n\n\n会话Bean主要处理业务逻辑\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:46',NULL),(00000000570,'假设web应用的文档根目录为MyApp，那么可以从哪里找到database.jar文件。\n\n\n\nA、 MyApp目录下\n\n\n\nB、 MyApp\\images目录下\n\n\n\nC、 MyApp\\WEB-INF目录下\n\n\n\nD、 MyApp\\WEB-INF\\lib目录下\n\n\n\n','解答：D\n\n\n\nWeb工程的lib是放置.jar文件的地方。\n\n\n\n','4','chose','Java语法',NULL,'2017-03-12 14:55:46',NULL),(00000000571,'从以下哪一个选项中可以获得Servlet的初始化参数。\n\n\n\nA、Servlet\n\n\n\nB、ServletContext\n\n\n\nC、ServletConfig\n\n\n\nD、GenericServlet\n\n\n\n','解答：C\n\n\n\nservlet的生命周期的方法中有一个init方法，其中一个重载的init方法的参数为ServletConfig可以获取初始化参数。\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:46',NULL),(00000000572,'哪一个对象可以用于获得浏览器发送的请求。\n\n\n\nA、HttpServletRequest\n\n\n\nB、HttpServletResponse\n\n\n\nC、HttpServlet\n\n\n\nD、Http\n\n\n\n','解答：A\n\n\n\nHttpServletRequest中有一些方法可以获取浏览器发送的请求信息。\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:46',NULL),(00000000573,'运行jsp需要安装_______Web服务器。\n\n\n\nA、Apache\n\n\n\nB、tomcat\n\n\n\nC、WebLogic\n\n\n\nD、IIS\n\n\n\n','解答：BC\n\n\n\nApache是PHP程序运行的服务器，IIS是.net程序运行的服务器。\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:46',NULL),(00000000574,'如何取得数据源。\n\n\n\nA、通过Http\n\n\n\nB、通过ftp\n\n\n\nC、JNDI\n\n\n\nD、通过Connection对象\n\n\n\n','解答：C\n\n\n\n在服务器上配置好数据以后，通过JNDI技术获取到数据源。\n\n\n\nJNDI：Java Naming and Directory Interface一种标准的Java命名系统接口\n\n\n\n','5','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000575,'下列哪一个接口定义了用于查找、创建和删除EJB实例\n\n\n\nA、Home\n\n\n\nB、Remote\n\n\n\nC、Local\n\n\n\nD、Message\n\n\n\n','解答：A\n\n\n\nremote接口定义了业务方法，用于EJB客户端调用业务方法。 home接口是EJB工厂用于创建和移除查找EJB实例\n\n\n\n','1','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000576,'在服务器的网络编程中，解决会话跟踪的方法有：\n\n\n\nA、 使用Cookie。\n\n\n\nB、 使用URL重写。\n\n\n\nC、 使用隐藏的表单域。\n\n\n\nD、 以上方法都不能单独使用。\n\n\n\n','解答：ABC\n\n\n\nURL重写就是首先获得一个进入的URL请求然后把它重新写成网站可以处理的另一个URL的过程\n\n\n\n隐藏域是在页面级保存信息。与其他用户标准控件的区别是，隐藏域不被呈现在页面中。当页面提交的时候，隐藏域中的值将被一同发送给服务端。\n\n\n\nCookie是以文本存储于计算机中，使用name-value匹配。一般用户存储标识用户信息\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000577,'与HttpSessionListener接口有关的方法是。\n\n\n\nA、sessionInitialized()\n\n\n\nB、sessionCreated()\n\n\n\nC、sessionFinialized()\n\n\n\nD、sessionDestroyed()\n\n\n\n','解答：BD\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000578,'关于JSP生命周期的叙述，下列哪些为真？\n\n\n\nA、JSP会先解释成Servlet源文件，然后编译成Servlet类文件\n\n\n\nB、每当用户端运行JSP时，jspInit()方法都会运行一次\n\n\n\nC、每当用户端运行JSP时，_jspService()方法都会运行一次\n\n\n\nD、每当用户端运行JSP时，jspDestroy()方法都会运行一次\n\n\n\n','解答：AC\n\n\n\n','5','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000579,'以下声明正确的是。\n\n\n\nA、<xml-stylesheet type=”txt/css” href=”abC、css”>\n\n\n\nB、<?xml-stylesheet type=’txt/css’ href=’abC、css’?>\n\n\n\nC、<?xml-stylesheet type=”txt/css” href=”abC、css”?>\n\n\n\nD、<%xml-stylesheet type=”txt/css” href=”abC、css”%>\n\n\n\n','解答BC\n\n\n\n单引号，双引号都可以使用在属性上。\n\n\n\n','5','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000580,'下列哪个为JSP的隐含对象。\n\n\n\nA、env\n\n\n\nB、page\n\n\n\nC、jspinfo\n\n\n\nD、context\n\n\n\n','解答：B\n\n\n\nJSP有九个隐士对象\n\n\n\nrequest对象：保存了很多客户端请求的信息。\n\n\n\nresponse对象：生成服务器端响应，然后将响应结果发送到客户端\n\n\n\nout对象：表示输出流，此输出流将作为请求发送到客户端\n\n\n\nsession对象：我们写个对象放在这个session对象中,这个对象就在我们的会话中都存在。\n\n\n\napplication对象:我们写个对象放在这个application对象中，这个对象就在整个应用程序中都存在\n\n\n\npageContext对象相当于当前页面的容器，可以访问当前页面的所有对象。\n\n\n\npaget对象:一般我们使用Page指令来替代使用这个对象\n\n\n\nexception对象：用来处理异常的\n\n\n\nconfig对象：一样的我们在页面中是使用很少的，一般会在Servlet中使用这个\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000581,'下面的那一个不属于MVC模式中的对象？\n\n\n\nA、 Model\n\n\n\nB、 View\n\n\n\nC、 Collection\n\n\n\nD、 Controller\n\n\n\n','解答：C\n\n\n\nMVC是三个单词的缩写,分别为： 模型(Model),视图(View)和控制Controller)。 MVC模式的目的就是实现Web系统的职能分工。 Model层实现系统中的业务逻辑，通常可以用JavaBean或EJB来实现。 View层用于与用户的交互，通常用JSP来实现。 Controller层是Model与View之间沟通的桥梁，\n\n\n\n它可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000582,'要创建一个EJB，必须要至少编写哪些Java类和接口？\n\n\n\nA、 定义远程(或业务)接口\n\n\n\nB、 定义本地接口\n\n\n\nC、 定义Bean接口\n\n\n\nD、 编写Bean的实现\n\n\n\n','解答：ABC\n\n\n\n','5','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000583,'XML 是一种元语言, 可以用它来描述其他语言。\n\n\n\nA、正确\n\n\n\nB、错误\n\n\n\n','解答：B\n\n\n\nXML（Extensible Markup Language）即可扩展标记语言，它与HTML一样，都是SGML(Standard Generalized Markup Language,标准通用标记语言)。Xml是Internet环境中跨平台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言XML是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然XML占用的空间比二进制数据要占用更多的空间，但XML极其简单易于掌握和使用。\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000584,'类图用来表示系统中类和类与类之间的关系，它是对系统动态结构的描述。(选择1项)\n\n\n\nA、正确\n\n\n\nB、不正确\n\n\n\n','解答：B\n\n\n\n类图是对系统静态结构的描述。\n\n\n\n','2','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000585,'哪一个不是EL定义的隐式对象？(选择1项)\n\n\n\nA cookie\n\n\n\nB、pageContext\n\n\n\nC、attributes\n\n\n\nD initParam\n\n\n\n','解答：C\n\n\n\n1)pageContext：JSP 页的上下文。它可以用于访问 JSP 隐式对象。\n\n\n\n2)Param：将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter\n\n\n\n(String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式 $(param.name) 相当于 request.getParameter (name)。\n\n\n\n3)paramValues：将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 ${paramvalues.name) 相当于 request.getParamterValues(name)。\n\n\n\n4)header将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 ${header.name} 相当于 request.getHeader(name)。\n\n\n\n5)headerValues将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式 ${headerValues.name} 相当于 request.getHeaderValues(name)。\n\n\n\n6)cookie将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式 ${cookie.name.value} 返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用 ${headerValues.name} 表达式。\n\n\n\n7)initParam将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。\n\n\n\n8)pageScope将页面范围的变量名称映射到其值。例如，EL 表达式可以使用 ${pageScope.objectName} 访问一个 JSP 中页面范围的对象，还可以使用 ${pageScope.objectName.attributeName} 访问对象的属性。\n\n\n\n9)requestScope将请求范围的变量名称映射到其值。该对象允许访问请求对象的属性。例如，EL 表达式可以使用 ${requestScope.objectName} 访问一个 JSP 请求范围的对象，还可以使用 ${requestScope.objectName.attributeName} 访问对象的属性。\n\n\n\n10)sessionScope将会话范围的变量名称映射到其值。该对象允许访问会话对象的属性。例\n\n\n\n11)applicationScope将应用程序范围的变量名称映射到其值。该隐式对象允许访问应用程序范围的对象。\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000586,'下面哪些属于JSTL中的表达式操作标签。(选择1项)\n\n\n\nA、<c:out>\n\n\n\nB、<c:if>\n\n\n\nC、<c:url>\n\n\n\nD、<c:catch>\n\n\n\n','解答：A\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000587,'Struts框架可以支持以下哪种程序开发语言？(选择1项)\n\n\n\nA、C\n\n\n\nB、C++\n\n\n\nC、Java\n\n\n\nD、C#\n\n\n\n','解答：C\n\n\n\n','3','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000588,'在Servlet处理请求的方式为。(选择1项)\n\n\n\nA、以进程的方式\n\n\n\nB、以程序的方式\n\n\n\nC、以线程的方式\n\n\n\nD、以响应的方式\n\n\n\n','解答：C\n\n\n\nServlet采用多线程来处理多个请求同时访问，Servlet容器维护了一个线程池来服务请求。\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000589,'javax.Servlet的包中，属于类的是。(选择1项)\n\n\n\nA、Servlet\n\n\n\nB、GenericServlet\n\n\n\nC、ServletRequest\n\n\n\nD、ServletContext\n\n\n\n','解答：B\n\n\n\nServletContext和ServletRequest是该包下的接口。\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000590,'以下说法正确的是。（选择2项）\n\n\n\nA、#CDATA标记表示该元素包含的数据将被解析器解释\n\n\n\nB、#PCDATA 标记表示该元素包含的数据将不被解析器解释\n\n\n\nC、#PCDATA 标记表示该元素包含的数据将被解析器解释\n\n\n\nD、#CDATA 标记表示该元素包含的数据将不被解析器解释\n\n\n\n','解答：AC\n\n\n\n在DTD中，指定某个标签中的内容是字符数据时，使用(#PCDATA)。而指定标签中某个属性的类型为字符型时，使用CDATA，都将被解析器解释。\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000591,'Http缺省的请求方法是。(选择1项)\n\n\n\nA、PUT\n\n\n\nB、GET\n\n\n\nC、POST\n\n\n\nD、TRACE\n\n\n\n','解答：B\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000592,'在XML中用于注释的符号是。(选择1项)\n\n\n\nA、<!– –>\n\n\n\nB、<?– –?>\n\n\n\nC、<% %>\n\n\n\nD、<!– –!>\n\n\n\n','解答：A\n\n\n\n','5','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000593,'DTD与XML Schema都是XML文档。(选择1项)\n\n\n\nA、正确\n\n\n\nB、不正确\n\n\n\n','解答：DTD不是XML文件， schema是XML文档\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000594,'JDBC中，用于表示数据库连接的对象是。(选择1项)\n\n\n\nA、Statement\n\n\n\nB、Connection\n\n\n\nC、 DriverManager\n\n\n\nD、PreparedStatement\n\n\n\n','解答：B\n\n\n\nStatement和PreparedStatement都是用来发送和执行SQL语句的\n\n\n\nDriverManager管理一组驱动程序\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000595,'用于调用存储过程的对象是。(选择1项)\n\n\n\nA、ResultSet\n\n\n\nB、DriverManager\n\n\n\nC、CallableStatemet\n\n\n\nD、PreparedStatement\n\n\n\n','解答：C\n\n\n\nResultSet是结果集对象\n\n\n\nDriverManager管理一组驱动程序\n\n\n\nPreparedStatement预编译的，用来发送和执行SQL语句的\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000596,'如果没有指定Cookie的时效，那么默认的时效是。(选择1项)\n\n\n\nA、一天\n\n\n\nB、 永不过期\n\n\n\nC、会话级别\n\n\n\nD、一分钟\n\n\n\n','解答：C\n\n\n\n这是API的原文：By default, -1 indicating the cookie will persist until browser shutdown.\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000597,'<?xml version=”1.0″ encoding=”GB2312″?>\n\n\n\n<!ELEMENT Customer EMPTY>\n\n\n\n<!ATTLIST Customer称呼 CDATA #IMPLIED姓名 CDATA #REQUIRED职位 CDATA #REQUIRED>关于上述DTD定义的描述正确的是。(选择1项)\n\n\n\nA、Customer元素能包含子元素，并且能为空\n\n\n\nB、Customer元素能包含文本，并且能为空\n\n\n\nC、Customer元素不能包含文本，也不能包含子元素\n\n\n\nD、Customer元素的所有实例的“称呼”属性必须有值，不能为空\n\n\n\n','解答：C\n\n\n\nEMPTY表示元素不能包含文本，也不能包含子元素\n\n\n\n#IMPLIED属性可以没有值\n\n\n\n#REQUIRED属性必须有值\n\n\n\n','5','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000598,'实现现下列哪一种接口的对象，并不需要在weB、xml文件内进行额外的设定，Servlet容器就能够回应该对象加入HTTP会话所发生的事件？(选择1项)\n\n\n\nA、ServletContextListener\n\n\n\nB、HttpSessionListener\n\n\n\nC、HttpSessionAttributeListener\n\n\n\nD、HttpSessionBindingListener\n\n\n\n','解答：D\n\n\n\nHttpSessionListener只需要设置到weB、xml中就可以监听整个应用中的所有session。HttpSessionBindingListener必须实例化后放入某一个session中，才可以进行监听\n\n\n\n','2','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000599,'下列哪个为JSP的小脚本的标签？(选择1项)\n\n\n\nA、<% %>\n\n\n\nB、<@ %>\n\n\n\nC、<%! %>\n\n\n\nD、<%– %>\n\n\n\n','解答：A\n\n\n\n','3','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000600,'以下不属于JSP的标准指令的是。(选择1项)\n\n\n\nA、Taglib\n\n\n\nB、Include\n\n\n\nC、Import\n\n\n\nD、Page\n\n\n\n','解答：C\n\n\n\nimport是page指令的一个属性。\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000601,'对于每一个网站访问用户都要访问的变量，应该将它设为________变量。(选择1项)\n\n\n\nA、 Session\n\n\n\nB、 Reques\n\n\n\nC、 Response\n\n\n\nD、 Application\n\n\n\n','解答：D\n\n\n\nApplication应用程序级变量\n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000602,'EJB类库存在于Java的哪个版本中？(选择1项)。\n\n\n\nA、 J2SE\n\n\n\nB、 J2EE\n\n\n\nC、 J2ME\n\n\n\nD、 J2NE\n\n\n\n','解答：B\n\n\n\nJava分为三个体系\n\n\n\nJavaSE(Java2 Platform Standard Edition，java平台标准版)，\n\n\n\nJavaEE(Java 2 Platform,Enterprise Edition，java平台企业版)，\n\n\n\nJavaME(Java 2 Platform Micro Edition，java平台微型版)。\n\n\n\nEJB属于JavaEE版本\n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000603,'察看下列JSP内容\n\n\n\n<html><body>\n\n\n\n<% for (int i=0;i<3;i++){ %>\n\n\n\nout.print(i*2);\n\n\n\n<% } %>\n\n\n\n</body></html>\n\n\n\n当这个JSP被运行时，其结果是什么？(选择1项)\n\n\n\nA、此JSP因为语法错误，无法运行\n\n\n\nB、显示出0，2，4\n\n\n\nC、显示出0，2，4，6\n\n\n\nD、显示出out.print(i*2) out.print(i*2) out.print(i*2)\n\n\n\n','解答：D\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:47',NULL),(00000000604,'假设A、jsp内设定一个<jsp:useBean>元素：\n\n\n\n<jsp:useBean id=”bean1” class=”myBean” />\n\n\n\n下列哪一个为真？(选择1项)\n\n\n\nA、bean1的存取范围（scope）默认为application\n\n\n\nB、在HTTP会话内可以存取bean1\n\n\n\nC、只有在A、jsp内可以存取bean1\n\n\n\nD、在A、jsp所属的Web应用程序内均可存取bean1\n\n\n\n','解答：C\n\n\n\nbean1的存取范围（scope）默认为page\n\n\n\n(题有一点问题 javabean的规则是要放在一个包中)\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000605,'在MVC设计模式中，JavaBean的作用是。(选择1项)\n\n\n\nA、Controller\n\n\n\nB、Model\n\n\n\nC、业务数据的封装\n\n\n\nD、View\n\n\n\n','解答：B\n\n\n\n同137题\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:47',NULL),(00000000606,'在J2EE中属于Web层的组件有(选择1项)\n\n\n\nA、 HTML\n\n\n\nB、 EJB\n\n\n\nC、 Applet\n\n\n\nD、 JSP\n\n\n\n','解答：D\n\n\n\n','3','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000607,'单元测试是在软件开发过程中的哪个阶段完成的？ (选择1项)\n\n\n\nA、 可行性研究和计划\n\n\n\nB、 概要设计\n\n\n\nC、 实现\n\n\n\nD、 使用和维护\n\n\n\n','解答：C\n\n\n\n','3','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000608,'在J2EE的Web应用中，编译后的class文件存放的目录为(选择1项)\n\n\n\nA、 classes目录\n\n\n\nB、 images目录\n\n\n\nC、 jar目录\n\n\n\nD、 任意位置\n\n\n\n','解答：A\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000609,'HttpServlet中，用来处理POST请求的方法是(选择1项)\n\n\n\nA、 doHead\n\n\n\nB、 doGet\n\n\n\nC、 doPost\n\n\n\nD、 doPut\n\n\n\n','解答：C\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:47',NULL),(00000000610,'DOM中XMLDOMnodelist的length属性的表示是：（选择1项）\n\n\n\nA、 该对象中文本字符的长度\n\n\n\nB、 该对象中元素节点的数量\n\n\n\nC、 该对象中节点的数量\n\n\n\nD、 该对象中文档对象的数量\n\n\n\n','解答：A\n\n\n\nlength 属性返回注释节点中的文本长度，以字符数计。\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000611,'如何创建Cookie? (选择1项)\n\n\n\nA、 使用new Cookie语句\n\n\n\nB、 调用response.addCookie方法\n\n\n\nC、 使用Cookie的setMaxAge方法\n\n\n\nD、 setCookie方法\n\n\n\n','解答：B\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000612,' 关于Web应用程序，下列说法错误的是（ ）。\n\n\n\nA、WEB-INF目录存在于web应用的根目录下\n\n\n\nB、 WEB-INF目录与classes 目录平行\n\n\n\nC、 weB、xml在WEB-INF目录下\n\n\n\nD、 Web应用程序可以打包为war文件\n\n\n\n','解答：B\n\n\n\n \n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000613,'有关Servlet的生命周期说法正确的有（ ）。\n\n\n\nA、Servlet的生命周期由Servlet实例控制\n\n\n\nB、init()方法在创建完Servlet实例后对其进行初始化，传递的参数为实现ServletContext接口的对象\n\n\n\nC、service()方法响应客户端发出的请求\n\n\n\nD、destroy()方法释放Servlet实例\n\n\n\n','解答：C\n\n\n\nServlet 生命周期就是指创建 Servlet 实例后响应客户请求直至销毁的全过程.\n\n\n\nSerlvet 生命周期的三个方法:init()–>service()–>destroy()，\n\n\n\nServlet生命周期的各个阶段: 实例化:Servlet 容器创建\n\n\n\nServlet 类的实例对象\n\n\n\n初始化:Servlet 容器调用 Servlet 的 init()方法\n\n\n\n服务:如果请求 Servlet,则容器调用 service()方法\n\n\n\n销毁:销毁实例之前调用 destroy()方法\n\n\n\n','3','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000614,'以下weB、xml片断（ ）正确地声明servlet 上下文参数。\n\n\n\nA\n\n\n\n<init-param>\n\n\n\n<param-name>MAX</param-name>\n\n\n\n<param-value>100</param-value>\n\n\n\n</init-param>\n\n\n\nB\n\n\n\n<context-param>\n\n\n\n<param name=”MAX” value=”100″ />\n\n\n\n<context-param>\n\n\n\nC\n\n\n\n<context>\n\n\n\n<param name=”MAX” value=”100″ />\n\n\n\n<context>\n\n\n\nD\n\n\n\n<context-param>\n\n\n\n<param-name>MAX</param-name>\n\n\n\n<param-value>100</param-value>\n\n\n\n<context-param>\n\n\n\n','解答：A\n\n\n\n','5','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000615,'以下（ ）可用于检索session属性userid的值。\n\n\n\nA、session. getAttribute (“userid”);\n\n\n\nB、session. setAttribute (“userid”);\n\n\n\nC、request. getParameter (“userid”);\n\n\n\nD、request. getAttribute (“userid”);\n\n\n\n','解答：A\n\n\n\n','4','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000616,'下列JSP代码：\n\n\n\n<html>\n\n\n\n<body>\n\n\n\n<%\n\n\n\nfor(int i = 0; i < 10; i++) {\n\n\n\n//1\n\n\n\n}\n\n\n\n%>\n\n\n\n</body>\n\n\n\n</html>\n\n\n\n以下（ ）可放置在//1处，不会发生编译错误。\n\n\n\nA <%= i %>\n\n\n\nB <b>i</b>\n\n\n\nC %><%= i %><%\n\n\n\nD不写任何内容\n\n\n\n','解答：CD\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000617,'考虑下面两个JSP文件代码片断： test1.jsp:\n\n\n\n<HTML>\n\n\n\n<BODY>\n\n\n\n<% pageContext.setAttribute(”ten”,new Integer(10));%>\n\n\n\n//1\n\n\n\n</BODY>\n\n\n\n</HTML>\n\n\n\ntest2.jsp:\n\n\n\n数字为：<%= pageContext.getAttribute(”ten”)%>\n\n\n\n以下（ ）放置在test1.jsp中的//1处，当请求test1.jsp时正确输出test2.jsp中的内容。\n\n\n\nA、<jsp:include page=”test2.jsp” />\n\n\n\nB、<jsp:forword page=”test2.jsp” />\n\n\n\nC、<%@ include file=”test2.jsp” %>\n\n\n\nD、由于pageContext对象的scope属性为page,所以test2.jsp不能访问test1.jsp定义的属性\n\n\n\n','解答：C\n\n\n\npageContext setAttribute(”ten”,new Integer(10));能取到的范围是page，也就是当前页面。\n\n\n\n<%@includefile=””%>：编译时包含,静态的，JSP引擎将对所包含的文件进行语法分析.\n\n\n\n<jsp:include page=””/>：运行时包含，静态和动态的都可以，JSP引擎不对所包含的文件进行语法分析，只获得处理的结果\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000618,'有关JSP隐式对象，以下（ ）描述正确。\n\n\n\nA、隐式对象是WEB容器加载的一组类的实例，可以直接在JSP页面使用\n\n\n\nB、不能通过config对象获取ServletContext对象\n\n\n\nC、response对象通过sendRedirect方法实现重定向\n\n\n\nD、只有在出错处理页面才有exception对象\n\n\n\n','解答：ACD\n\n\n\n可以通过config对象获取ServletContext对象\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000619,' 考虑下面JSP文件代码片断：\n\n\n\n<HTML>\n\n\n\n<BODY>\n\n\n\n<jsp:include page=”test2.jsp”>\n\n\n\n<jsp:param name=”username” value=”accp”/>\n\n\n\n</jsp:include>\n\n\n\n</BODY>\n\n\n\n</HTML>\n\n\n\n以下（ ）代码片断放置在test2.jsp中不会导致错误。\n\n\n\nA、<jsp:getParam name=”username”/>\n\n\n\nB、<jsp:include param =”username”/>\n\n\n\nC、<%=request.getParameter(“username”)%>\n\n\n\nD、<%=request.getAttribute(“username”)%>\n\n\n\n','解答：C\n\n\n\n','4','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000620,'以下是login.jsp文件的代码片断：\n\n\n\n<%@ page isELIgnored=”false”%>\n\n\n\n<html>\n\n\n\n<body>\n\n\n\n<FORM action=”login.jsp” method=”GET”>\n\n\n\n<input type=”text” name=”name” value=”${param[\'name\']}”>\n\n\n\n<input type=”submit” value=”提交”>\n\n\n\n</FORM>\n\n\n\n<P>\n\n\n\n用户名为: ${param.name}\n\n\n\n</body>\n\n\n\n</html>\n\n\n\n以下（ ）描述正确。\n\n\n\nA、发生运行错误\n\n\n\nB、页面会出现一文本框，并且文本框中内容为${param[\'name\']}\n\n\n\nC、当用户输入名字并单击“提交”按钮时，在同一页面中的“用户名为：”字样后面会显示用户输入的内容\n\n\n\nD、当用户输入名字并单击“提交”按钮时，在同一页面中的“用户名为：”字样后面会显示${param.name}\n\n\n\n','解答：C\n\n\n\n在每个JSP中也可以指定是否该JSP使用EL。在page directive中的isELIgnored属性用来指定是否忽略。格式为：\n\n\n\n＜%@ page isELIgnored＝”true|false”%＞\n\n\n\n如果设定为真，那么JSP中的表达式被当成字符串处理。\n\n\n\n','5','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000621,'doAfterBody()方法是在（ ）接口中定义的。\n\n\n\nA、Tag\n\n\n\nB、IterationTag\n\n\n\nC、BodyTag\n\n\n\nD、TagSupport\n\n\n\n','解答：B\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000622,'下面代码片断在浏览器中输出结果为（ ）。\n\n\n\n<c:set var=”myVar” scope =”session”>\n\n\n\n2+3\n\n\n\n</c:set>\n\n\n\n<c:out value=”${myVar}”/>\n\n\n\nA、0\n\n\n\nB、5\n\n\n\nC、2+3\n\n\n\nD、无输出\n\n\n\n','解答：C\n\n\n\n<c:set>标签主要用来将变量保存到JSP 的会话中或JavaBean 的属性中。<c:set>的语法格式为： <c:set value=”value” var=”varName” [scope=\"{ page|request|session|application }\"]/> 上述的表达式实现的功能是将 value 的值储存至范围为scope 的 varName 变量之中，还可以将 value 的值储存至 target 对象的属性中.如果题中2+3改成${2+3}那么结果就是5.\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000623,'编写一个Filter，除继承HttpServlet类外还需要（ ）。\n\n\n\nA、继承Filter 类\n\n\n\nB、实现Filter 接口\n\n\n\nC、继承HttpFilter 类\n\n\n\nD、实现HttpFilter接口\n\n\n\n','解答；B\n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000624,'以下哪个Hibernate主键生成策略是实现主键按数值顺序递增的？\n\n\n\nA、increment\n\n\n\nB、identity\n\n\n\nC、sequence\n\n\n\nD、native\n\n\n\n','解答：A\n\n\n\nincrement生成策略：当Hibernate准备在数据库表中插入一条新记录时，首先从数据库表中获取当前主键字段的最大值，然后在最大值基础上加1，作为当前持久化对象的标识符属性值。这种策略即increment生成策略，用其生成的标识符属性的类型可以是long、short、int及其封装类的类型\n\n\n\nidentity生成策略：在MS SQL Server、MySQL和DB2等数据库中可以设置表中某一个字段的数值自动增长，identity生成策略通过这种方式为当前记录获取主键值的同时为持久化对象赋予标识符属性值。\n\n\n\nsequence生成策略：在Oracle、DB2和PostgreSQL等数据库中创建一个序列（sequence），然后Hibernate通过该序列为当前记录获取主键值，进而为持久化对象赋予标识符属性值。\n\n\n\nnative生成策略：由Hibernate根据所使用的数据库支持能力从identity、sequence或者等生成策略中选择一种\n\n\n\n','4','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000625,'在jsp中，page指令的（）属性用来引入需要的包或类。\n\n\n\nA、extends\n\n\n\nB、import\n\n\n\nC、language\n\n\n\nD、contentType\n\n\n\n','解答：B\n\n\n\npage指令属性简要介绍：\n\n\n\nlanguage=”java”\n\n\n\n声明脚本语言的种类，暂时只能用”java”\n\n\n\nextends=”package.class”\n\n\n\n标明JSP编译时需要加入的Java Class的全名，但是得慎重的使用它，它会限制JSP的编译能力.\n\n\n\nimport=”{package.class | package.* }, …”\n\n\n\n需要导入的Java包的列表，这些包就作用于程序段，表达式，以及声明。\n\n\n\n下面的包在JSP编译时已经导入了，所以你就不需要再指明了:\n\n\n\njavA、lang.*\n\n\n\njavax.servlet.*\n\n\n\njavax.servlet.jsp.*\n\n\n\njavax.servlet.http.*\n\n\n\nsession=”true | false”\n\n\n\n设定客户是否需要HTTP Session.如果它为true,那么Session是有用的。\n\n\n\n如果它有false,那么你就不能使用session对象，以及定义了scope=session的<jsp:useBean>元素。这样的使用会导致错误. 缺省值是true.\n\n\n\nbuffer=”none | 8kb | sizekb”\n\n\n\nbuffer的大小被out对象用于处理执行后的JSP对客户浏览器的输出。\n\n\n\n缺省值是8kb\n\n\n\nautoFlush=”true | false”\n\n\n\n设置如果buffer溢出，是否需要强制输出，如果其值被定义为true(缺省值)，输出正常，如果它被设置为false,如果这个buffer溢出，就会导致一个意外错误的发生.如果你把buffer设置为none,那么你就不能把autoFlush设置为false.\n\n\n\nisThreadSafe=”true | false”\n\n\n\n设置Jsp文件是否能多线程使用。缺省值是true,也就是说，JSP能够同时处理多个用户的请求，如果设置为false，一个jsp只能一次处理一个请求\n\n\n\ninfo=”text”\n\n\n\n一个文本在执行JSP将会被逐字加入JSP中，你能够使用\n\n\n\nServlet.getServletInfo方法取回。\n\n\n\nerrorPage=”relativeURL”\n\n\n\n设置处理异常事件的JSP文件。\n\n\n\nisErrorPage=”true | false”\n\n\n\n设置此页是否为出错页，如果被设置为true,你就能使用exception对象.\n\n\n\ncontentType=”mimeType [ ;charset=characterSet ]” | “text/html;charset=ISO-8859-1″\n\n\n\n设置MIME类型 。缺省MIME 类型是: text/html, 缺省字符集为 ISO-8859-1.\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000626,'正则表达式”\\d+\\.?\\d*”在匹配下列字符串时结果是失败的是？\n\n\n\nA 12.5\n\n\n\nB 1.25\n\n\n\nC 以上都成功\n\n\n\nD 以上都失败\n\n\n\n','解答：B\n\n\n\n\\d+ 表示可以出现1次或是n次数字\n\n\n\n\\. .? 表示可以“.”可以出现一次，也可以不出现\n\n\n\n\\d* 表示可以出现0次或是n次数字\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000627,'下列没有直接采用XML技术的是（ ）\n\n\n\nA、 UDDI\n\n\n\nB、 SOAP\n\n\n\nC、 AJAX\n\n\n\nD、DCOM\n\n\n\n','解答：D\n\n\n\nDCOM（分布式组件对象模型,分布式组件对象模式）是一系列微软的概念和程序接口，利用这个接口，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。DCOM基于组件对象模型（COM），COM提供了一套允许同一台计算机上的客户端和服务器之间进行通信的接口（运行在Windows95或者其后的版本上）。\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000628,'下列可以用来解析XML的是（ ）\n\n\n\nA、CSS\n\n\n\nB、DTD\n\n\n\nC、SAX\n\n\n\nD、XSL\n\n\n\n','解答：C\n\n\n\njava解析xml文件四种方式：SAX DOM JDOM DOM4J\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000629,'下面关于XML叙述不正确的是（ ）\n\n\n\nA、XML标记必须关闭\n\n\n\nB、XML是大小写敏感的\n\n\n\nC、XML文件只能跟DTD文件一块使用\n\n\n\nD、XML和XSL结合可以在浏览器上显示\n\n\n\n','解答：C\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000630,'在不指定特殊属性的情况下，哪几种HTML标签可以手动输入文本：（）\n\n\n\nA、 <TEXTAREA></TEXTAREA>\n\n\n\nB、 <INPUT type=”text”/>\n\n\n\nC、 <INPUT type=”hidden”/>\n\n\n\nD、 <DIV></DIV>\n\n\n\n','解答：AB\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000631,'关于IFrame表述正确的有：()\n\n\n\nA、 通过IFrame，网页可以嵌入其他网页内容，并可以动态更改\n\n\n\nB、 在相同域名下，内嵌的IFrame可以获取外层网页的对象\n\n\n\nC、 在相同域名下，外层网页脚本可以获取IFrame网页内的对象\n\n\n\nD、 可以通过脚本调整IFrame的大小\n\n\n\n','解答：CD\n\n\n\nIFRAME 元素也就是文档中的文档，或者好像浮动的框架(FRAME)。\n\n\n\n通过 iframe 对象所在页面的对象模型，你可以访问 iframe 对象的属性，但不能访问其内容。\n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000632,'关于表格表述正确的有：（）\n\n\n\nA、 表格中可以包含TBODY元素\n\n\n\nB、 表格中可以包含CAPTION元素\n\n\n\nC、 表格中可以包含多个TBODY元素\n\n\n\nD、 表格中可以包含COLGROUP元素\n\n\n\nE. 表格中可以包含COL元素\n\n\n\n','解答\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000633,'关于表格表述正确的有：（）\n\n\n\nA、 表格中可以包含TBODY元素\n\n\n\nB、 表格中可以包含CAPTION元素\n\n\n\nC、 表格中可以包含多个TBODY元素\n\n\n\nD、 表格中可以包含COLGROUP元素\n\n\n\nE. 表格中可以包含COL元素\n\n\n\n','解答：ACDE\n\n\n\ncaption标签用于定义一个表格标题。<caption>标签只能出现在table标签中，且必须紧随table标签之后。每个表格只能定义一个标题。\n\n\n\n使用 <tbody> 标签，可以将表格分为一个单独的部分。<tbody> 标签可将表格中的一行或几行合成一组。\n\n\n\n利用<colgroup>标签可以把表格按列划分为若干组，每组可包含一列或几列，然后可以对各组分别设置格式。\n\n\n\n通常一个列组的各列格式是相同的，如果列与列有差异，可通过在组内加入<col>标签进行设置。<col>标签只能在<table>标签和<colgroup>标签中使用。\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000634,'在DHTML中把整个文档的各个元素作为对象处理的技术是：（）\n\n\n\nA、HTML\n\n\n\nB、CSS\n\n\n\nC、DOM\n\n\n\nD、Script(脚本语言)\n\n\n\n','解答：C\n\n\n\nDOM：文档对象模型\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000635,'下面属于javascript对象的有：( )\n\n\n\nA、 Window\n\n\n\nB、 Document\n\n\n\nC、 Form\n\n\n\nD、 String\n\n\n\nE. Navigator\n\n\n\n','解答：ACE\n\n\n\n','5','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000636,'Servlet程序的入口点是？（ ）\n\n\n\nA、init（）\n\n\n\nB、main（）\n\n\n\nC、service（）\n\n\n\nD、doGet（）\n\n\n\n','解答：C\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000637,'不能在不同用户之间共享数据的方法是？（ ）\n\n\n\nA、通过cookie\n\n\n\nB、利用文件系统\n\n\n\nC、利用数据库\n\n\n\nD、通过ServletContext对象\n\n\n\n','解答：A\n\n\n\n','2','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000638,' 模块内聚度越高，说明模块内各成分彼此结合的程度越 A 松散 B 紧密 C 无法判断 D 相同\n\n\n\n','解答：B\n\n\n\n内聚度是指模块内部各成分之间的联结强度.内聚度越高,越容易理解、修改和维护.但内聚度本身是主观的、非形式化的概念,程序设计人员很难客观地评估一个模块的内聚度.为此,人们开发出许多度量准则用于量化模块的内聚度[1~3],为程序设计人员开发出高内聚度的模块提供指南. \n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:48',NULL),(00000000639,' (单选)软件需求分析阶段的输出主要是 A、 需求说明书 B、 开发计划 C、 可行性报告 D、 设计说明书\n\n\n\n','解答：A \n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000640,' (单选) 以下选项中不是项目经理的职责的是？ A、 需求分析 B、 计划 C、 计划跟踪 D、 质量管理 \n\n','解答：D\n\n\n\n质量管理是SQA（软件质量保证）人员的职责 \n\n','1','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000641,' (多选)配置管理能起到以下哪些作用？ A、 版本管理\n\n\n\nB、 变更管理 C、 需求管理 D、 测试管理\n\n\n\n','解答：AB\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000642,'下面的哪个方法在servlet的response的输出流在URL中保存Session ID。（ ）\n\n\n\nA、The encodeURL method of the HttpServletRequest interface.\n\n\n\nB、 The encodeURL method of the HttpServletResponse interface.\n\n\n\nC、The rewriteURL method of the HttpServletRequest interface.\n\n\n\nD、 The rewriteURL method of the HttpServletResponse interface.\n\n\n\n','解答：B\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000643,'看下面这个类\n\n\n\npublic class IfAttributsChanged implements ServletContextAttributeListener{\n\n\n\npublic void attributeAdded(ServletContextAttributeEvent scab){\n\n\n\nSystem.out.println(“加入一个属性”);\n\n\n\n}\n\n\n\npublic void attributeRemoved(ServletContextAttributeEvent scab){\n\n\n\nSystem.out.println(“删除一个属性”);\n\n\n\n}\n\n\n\n}\n\n\n\n关于IfAttributsChanged类的叙述，下列哪一个为真？(选择1项)\n\n\n\nA、此类可以成功编译\n\n\n\nB、此类无法成功编译，原因是缺少attributeChanged()方法。\n\n\n\nC、此类无法成功编译，原因是缺少attributeReplaced()方法。\n\n\n\nD、此类无法成功编译，原因是缺少attributeUpdated()方法。\n\n\n\n','解答：C\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000644,'Oracle数据库表空间与用户的关系是 ( )?\n\n\n\nA、一对一\n\n\n\nB、一对多\n\n\n\nC、多对一\n\n\n\nD、多对多\n\n\n\n','解答： D\n\n\n\n一个用户可以使用一个或多个表空间，一个表空间也可以供多个用户使用。\n\n\n\n','5','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000645,'Oracle数据库表空间与数据文件的关系描述正确的是( )\n\n\n\nA、一个表空间只能对应一个数据文件\n\n\n\nB、一个表空间可以对应多个数据文件\n\n\n\nC、一个数据文件可以对应多个表空间\n\n\n\nD、表空间与数据文件没任何对应关系\n\n\n\n','解答：B\n\n\n\n表空间和数据文件发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，\n\n\n\n而一个数据文件只能隶属一个表空间\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000646,'判断这PL/SQL 代码块：(选择1项)\n\n\n\nBEGIN\n\n\n\nFOR i IN 1..6 LOOP\n\n\n\nIF i = 2 OR i = 3 THEN null;\n\n\n\nELSE\n\n\n\nINSERT INTO example(one) VALUES (i);\n\n\n\nEND IF;\n\n\n\nROLLBACK;\n\n\n\nEND LOOP;\n\n\n\nCOMMIT;\n\n\n\nEND;\n\n\n\n有多少行被插入到表 EXAMPLE ?\n\n\n\nA、0\n\n\n\nB、1\n\n\n\nC、2\n\n\n\nD、3\n\n\n\n','解答：A\n\n\n\n在循环结束前执行了ROLLBACK 语句，数据被回滚。\n\n\n\n','3','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000647,'你判断下面语句，有什么作用？(单选)\n\n\n\nGRANT update ON inventory TO joe WITH GRANT OPTION;\n\n\n\nA、一个系统权限被授予用户JOE\n\n\n\nB、一个对象权限被授予用户JOE\n\n\n\nC、用户JOE被授予在这个对象上的所有权限\n\n\n\nD、一个系统权限和一个对象权限被授予用户JOE\n\n\n\n','解答：B\n\n\n\nwith admin option 只能在赋予 system privilege 的时使用 with grant option 只能在赋予 object privilege 的时使用\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:48',NULL),(00000000648,'表 CLASSES 和 表 SCHEDULE 结构如下:\n\n\n\nCLASSES：\n\n\n\nID NUMBER(9)\n\n\n\nCLASS_NAME VARCHAR2(20)\n\n\n\nTEACHER_ID NUMBER(9)\n\n\n\nSCHEDULE：\n\n\n\nCLASS_TIME DATE\n\n\n\nCLASS_ID NUMBER(9)\n\n\n\n你建一个视图显示每一课的课名、课时，并按教师ID排序，判断下面语句将返回何种结果？ (选择1项)\n\n\n\nCREATE VIEW class_schedule AS\n\n\n\nSELECT C、class_name, s.class_time FROM classes c, schedule s WHERE C、id = s.class_id;\n\n\n\nA .语句创建视图 CLASS_SCHEDULE 且可产生预期结果.\n\n\n\nB .语句创建视图 CLASS_SCHEDULE 但不能产生预期结果.\n\n\n\nC .语法错误，因为视图不可基于连接查询.\n\n\n\nD .语法错，因为语句未包含 ORDER BY 子句.\n\n\n\n','解答：B\n\n\n\n上述试图显示每一课的课名、课时，但是没有按教师ID排序\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:48',NULL),(00000000649,'Oracle数据库中，在SQL语句中连接字符串的方法是哪个？(选择1项)\n\n\n\nA、cat\n\n\n\nB、concat\n\n\n\nC、join\n\n\n\nD、+\n\n\n\n','解答：B\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:49',NULL),(00000000650,'表 TEACHER 包含如下字段：\n\n\n\n列名\n\n\n\n可为空否？\n\n\n\n数据类型\n\n\n\nTEACHER_ID\n\n\n\nNOT NULL\n\n\n\nNUMBER(9)\n\n\n\nNAME\n\n\n\nVARCHAR2(25)\n\n\n\nSALARY\n\n\n\nNUMBER(7,2)\n\n\n\nSUBJECT_ID\n\n\n\nNOT NULL\n\n\n\nNUMBER(3)\n\n\n\nSUBJECT_DESCRIPTION\n\n\n\nVARCHAR2(2)\n\n\n\n你需要将理科教师的工资上浮8%，理科教师的SUBJECT_ID是011，你需用哪一句实现? (选择1项)\n\n\n\nA、UPDATE teacher SET salary = salary * 1.08 WHERE subject_description LIKE\n\n\n\n‘SCIENCE’\n\n\n\nB、UPDATE teacher SET salary = salary * .08 WHERE subject_description LIKE ‘SCIENCE’ AND subject_id = 011\n\n\n\nC、UPDATE teacher SET salary = salary * 1.08 WHERE subject_id = 011;\n\n\n\nD、UPDATE teacher SET salary = salary + (salary * .08) WHERE subject_description LIKE ‘SCIENCE’ OR subject_id = 011\n\n\n\n','解答：C\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000651,'定义游标如下：\n\n\n\nDECLARE\n\n\n\nCURSOR query_cursor(v_salary) IS\n\n\n\nSELECT last_name, salary, dept_no\n\n\n\nFROM employee\n\n\n\nWHERE salary>v_salary;\n\n\n\n这条语句为什么会错误？（选择1项）\n\n\n\nA、 在游标定义中不允许出现where子句\n\n\n\nB、 select语句中缺少into子句\n\n\n\nC、 参数未指定为变量数据类型\n\n\n\nD、 定义cursor的语法写错了\n\n\n\n','解答：C\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000652,'在 PL/SQL 块的哪部分可以对初始变量赋予新值? (选择1项)\n\n\n\nA、结尾部分\n\n\n\nB、开头部分\n\n\n\nC、执行部分\n\n\n\nD、声明部分\n\n\n\n','解答：C\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000653,'哪句可以实现显示 id 和 description ，条件满足订单时间在 January 1, 1997 以前的，且单价小于 1.00 或者大于 5.00 的， 结果用订单时间降序排列。(选择1项)\n\n\n\nA、SELECT id_number, description FROM inventory\n\n\n\nWHERE price IN (1.00, 5.00) OR order_date < ’01-JAN-97′\n\n\n\nORDER BY order_date DESC;\n\n\n\nB、SELECT id_number, description FROM inventory\n\n\n\nWHERE price BETWEEN 1.00 AND 5.00 OR order_date < ’01-JAN-1997′\n\n\n\nORDER BY order_date;\n\n\n\nC、SELECT id_number, description FROM inventory\n\n\n\nWHERE price < 1.00 OR price > 5.00 AND order_date < ’01 -Jan-97′\n\n\n\nORDER BY order_date ASC;\n\n\n\nD、SELECT id_number, description FROM inventory\n\n\n\nWHERE (price <1.00 OR price > 5.00) AND order_date < ’01-JAN-1997′\n\n\n\nORDER BY order_date DESC;\n\n\n\n','解答：D\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000654,'判断下面句子，将返回什么值？ (选择1项)\n\n\n\nSELECT id_number, description, price FROM inventory\n\n\n\nWHERE manufacturer_id IN (SELECT manufacturer_id FROM inventory WHERE price > 8.00 OR quantity > 1000);\n\n\n\nA返回单价大于8.00且数量大于1000的存货的 货号、种类、单价信息\n\n\n\nB返回单价大于8.00或者数量大于1000的存货的 货号、种类、单价信息.\n\n\n\nC返回单价大于8.00或者数量大于1000且有制造商号的存货的 货号、种类、单价信息.\n\n\n\nD返回单价大于8.00或者数量大于1000的制造商的所有存货的 货号、种类、单价信息.\n\n\n\n','解答：C\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000655,'考虑下列声明，那些是不合法的：（选择3项）\n\n\n\nA、 DECLARE v_name, v_dept VARCHAR2(14);\n\n\n\nB、 DECLARE v_test NUMBER(5);\n\n\n\nC、 DECLARE V_MAXSALARY NUMBER(7, 2) = 5000;\n\n\n\nD、 DECLARE V_JOINDATE BOOLEAN := SYSDATE;\n\n\n\n','解答：ACD\n\n\n\nA、v_name没有数据类型\n\n\n\nC、:=是赋值\n\n\n\nD、V_JOINDATE是boolean类型，sysdate是Date类型\n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000656,'关于 PL/SQL 块的执行部分下列说法正确的是？(选择1项)\n\n\n\nA、PL/SQL 表达式可以包含分组函数.\n\n\n\nB、 PL/SQL表达式不可以包含SQL函数.\n\n\n\nC、 在SQL 语句中部分分组函数可用.\n\n\n\nD、 以上都不对\n\n\n\n','解答A\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000657,'表（TEACHER）包含以下列：\n\n\n\nID NUMBER(7) PK\n\n\n\nSALARY NUMBER(7,2)\n\n\n\nSUBJECT_ID NUMBER(7)\n\n\n\n判断以下两个SQL语句：\n\n\n\n（1）SELECT ROUND(SUM(salary),-2) FROM teacher ;\n\n\n\n（2）SELECT subject_id, ROUND(SUM(salary),-2) FROM teacher GROUP BY subject_id ;\n\n\n\n有什么不同结果? (选择1项)\n\n\n\nA、 语句1将返回每个老师一个结果\n\n\n\nB、 语句2将返回多个结果\n\n\n\nC、 结果相同，显示不同\n\n\n\nD、 将有一个句子产生错误\n\n\n\n','解答：B\n\n\n\n语句1会返回一个结果，就是所有老师的工资和，使用了四舍五入函数\n\n\n\n语句2 是按照subject_id进行分组，那么分几组就会有几个结果\n\n\n\n211.游标的哪一种属性指示fetch语句是否从活动集中返回行，如未能返回行，则此属性的值为\n\n\n\ntrue ？(选择1项)\n\n\n\nA、 %FOUND\n\n\n\nB、 %NOTFOUND\n\n\n\nC、 %ROWCOUNT\n\n\n\nD、 %ISOPEN\n\n\n\n解答：B\n\n\n\n%FOUND 布尔型属性，当最近一次读记录时成功返回,则值为TRUE；\n\n\n\n%NOTFOUND 布尔型属性，与%FOUND相反；\n\n\n\n%ISOPEN 布尔型属性，当游标已打开时返回 TRUE；\n\n\n\n%ROWCOUNT 数字型属性，返回已从游标中读取的记录数\n\n\n\n','3','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000658,'哪一子句可实现 SELECT 语句查询员工平均工资小于5000的部门信息 ? (选择1项)\n\n\n\nA、GROUP BY dept_id WHERE AVG(sal) < 5000\n\n\n\nB、GROUP BY AVG(sal) HAVING AVG(sal) < 5000\n\n\n\nC、GROUP BY dept_id HAVING AVG(sal) < 5000\n\n\n\nD、GROUP BY AVG(sal) < 5000\n\n\n\n','解答：C\n\n\n\n使用 HAVING 过滤分组。\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:49',NULL),(00000000659,'在PL/SQL中使用哪几种语句来对变量进行赋值？ (选择3项)\n\n\n\nA ：=\n\n\n\nB SELECT INTO\n\n\n\nC FETCH INTO\n\n\n\nD =\n\n\n\n','解答：ABC\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000660,'你试图用下面句子查询数据：(选择1项)\n\n\n\nSELECT 100/NVL(quantity, 0) FROM inventory;\n\n\n\n为何QUANTITY为 null 空值时，将导致出错？\n\n\n\nA、 表达式企图被空值除.\n\n\n\nB、换函数参数数据类型不一致.\n\n\n\nC、空值不能被转成实际值\n\n\n\nD、 表达式企图被零除.\n\n\n\n','解答：D\n\n\n\nnvl(表达式1，表达式2) 这个函数的作用是如果表达式1的值为null，那么取表达式2的值。\n\n\n\n','5','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000661,'PL/SQL的哪一部分实现对数据的操作? (选择1项)\n\n\n\nA、头部分\n\n\n\nB、列外部分\n\n\n\nC、执行部分\n\n\n\nD、声明部分\n\n\n\n','解答：C\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:49',NULL),(00000000662,'下列哪个集合操作符返回两个查询所选择的所有的行。(选择1项)\n\n\n\nA Union\n\n\n\nB Union all\n\n\n\nC Union only\n\n\n\nD connect by\n\n\n\n','解答：B\n\n\n\nUnion集合操作符返回两个查询所选择的去除重复行。\n\n\n\n','2','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000663,'在Oracle中，当需要使用显式游标更新或删除游标中的行时，UPDATE或DELETE语句必须使用（）子句。\n\n\n\nA、WHERE CURRENT OF\n\n\n\nB、WHERE CURSOR OF\n\n\n\nC、FOR UPDATE\n\n\n\nD、FOR CURSOR OF\n\n\n\n','解答：C\n\n\n\n为了对正在处理(查询)的行不被另外的用户改动，ORACLE 提供一个 FOR UPDATE 子句来对所选择的行进行锁住。该需求迫使ORACLE锁定游标结果集合的行，可以防止其他事务处理更新或删除相同的行，直到您的事务处理提交或回退为止。\n\n\n\n如果使用 FOR UPDATE 声明游标，则可在DELETE和UPDATE 语句中使用WHERE CURRENT OF cursor_name子句，修改或删除游标结果集合当前行对应的数据库表中的数据行。\n\n\n\n','4','chose','后台',NULL,'2017-03-12 14:55:49',NULL),(00000000664,'在Oracle中，使用下列的语句：CREATE PUBLIC SYNONYM parts FOR Scott.inventory;\n\n\n\n完成的任务是（）。\n\n\n\nA、将Scott.inventory对象的访问权限赋予所有用户\n\n\n\nB、指定了新的对象权限\n\n\n\nC、指定了新的系统权限\n\n\n\nD、给Scott.inventory对象创建一个公用同义词parts\n\n\n\n','解答：D\n\n\n\n使用同义词访问相同的对象，方便访问其它用户的对象，短对象名字的长度。\n\n\n\n','1','chose','后台',NULL,'2017-03-12 14:55:49',NULL),(00000000665,'在Oracle中，执行如下PL/SQL语句后\n\n\n\nCREATE TYPE car AS OBJECT ( id NUMBER, model VARCHAR2(25), color VARCHAR2(15) );\n\n\n\nDECLARE\n\n\n\nmyvar car.model%TYPE;\n\n\n\nBEGIN\n\n\n\nEND;\n\n\n\n变量myvar的数据类型为（）。\n\n\n\nA、NUMBER\n\n\n\nB、car类型\n\n\n\nC、VARCHAR2\n\n\n\nD、OBJECT\n\n\n\n','解答：C\n\n\n\n定义一个变量，其数据类型与已经定义的某个数据变量的类型相同，或者与数据库表的某个列的数据类型相同，这时可以使用%TYPE。\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000666,'有如下SQL片段\n\n\n\nA、select * from asdfh a where A、kehhao in (select kehhao from retail_vip )\n\n\n\nB、select * from asdfh a where exists (select r. kehhao from retail_vip r where r.kehhao = A、kehhao)\n\n\n\n则以下哪些描述是正确的：\n\n\n\nA a,b 含义相同\n\n\n\nB a的效率高于b\n\n\n\nC b的效率高于a\n\n\n\nD a,b 效率高低依赖于表 asdfh 和 kehhao的结构\n\n\n\nE a,b 效率高低需考虑表 asdfh和kehhao的数据量\n\n\n\n','解答：E\n\n\n\nin可以分为三类：\n\n\n\n形如select * from t1 where f1 in （ a ，b ），应该和以下两种比较效率\n\n\n\nselect * from t1 where f1= a or f1= b\n\n\n\n或者 select * from t1 where f1 = a union all select * from t1 f1= b\n\n\n\n形如select * from t1 where f1 in （select f1 from t2 where t2.fx= x）\n\n\n\n其中子查询的where里的条件不受外层查询的影响，这类查询一般情况下，自动优化会转成exist语句，也就是效率和exist一样。\n\n\n\n形如select * from t1 where f1 in （select f1 from t2 where t2.fx=t1.fx），\n\n\n\n其中子查询的where里的条件受外层查询的影响，这类查询的效率要看相关条件涉及的字段的索引情况和数据量多少，一般认为效率不如exists.\n\n\n\n除了第一类in语句都是可以转化成exists 语句的，一般编程习惯应该是用exists而不in\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000667,'有如下表结构\n\n\n\n客户号（kehhao）,日期（riqi）,账户余额(zhhuye)\n\n\n\n说明表a中记录客户不同日期账户余额，但仅在相邻两天任一客户（kehhao）账户余额（zhhuye）发生变化时，才在表a中添加新记录。\n\n\n\n日期(riqi)，其中包含多条日期：如20050101，20050110等\n\n\n\n则如下SQL片段含义为：\n\n\n\nSelect A、kehhao,C、riqi,A、zhhuye\n\n\n\n(Select B、riqi as riqi , max(A、riqi) as riqix from b,a where A、riqi <= B、riqi) c\n\n\n\nLeft join a\n\n\n\nOn A、riqi = C、 riqix\n\n\n\nA、选择表a中各个客户在给定日期（给定日期由表b存储）的余额信息\n\n\n\nB、选择表a中各个客户在除给定日期（给定日期由表b存储）的余额信息\n\n\n\nC、选择表a中各个客户最接近给定日期（给定日期由表b存储）的余额信息\n\n\n\nD、以上都不对\n\n\n\n','解答：D\n\n\n\n所有包含于SELECT 列表中，而未包含于组函数中的列都必须包含于 GROUP BY 子句中。\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000668,'有如下SQL片段\n\n\n\nDelete from asdfh a where A、kaihrq > ‘20091214’ and A、jiluzt <> ‘1’其含义为：\n\n\n\nA、从表asdfh中删除kaihrq 不小于2009年12月14日，且jiluzt不为1的记录\n\n\n\nB、从表asdfh中删除kaihrq 和 jiluzt列\n\n\n\nC、对表asdfh中删除kaihrq 不小于2009年12月14日，且jiluzt不为1的记录打删除标记\n\n\n\nD、以上都不正确\n\n\n\n','解答：C\n\n\n\n提交或回滚前的数据状态\n\n\n\n改变前的数据状态是可以恢复的\n\n\n\n执行 DML 操作的用户可以通过 SELECT 语句查询之前的修正\n\n\n\n其他会话不能看到当前用户所做的改变，直到当前会话结束事务。\n\n\n\nDML语句所涉及到的行被锁定， 其他会话不能操作。\n\n\n\n','1','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000669,'只有满足联接条件的记录才包含在查询结果中，这种联接为?\n\n\n\nA、左联接\n\n\n\nB、右联接\n\n\n\nC、内部联接\n\n\n\nD、完全联接\n\n\n\n','解答：C\n\n\n\n内连接 ：内连接查询操作列出与连接条件匹配的数据行\n\n\n\n外连接：返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左连接)、右表(右连接)或两个边接表(全外连接)中的所有数据行。\n\n\n\n','4','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000670,'分机构统计VIP客户的数量下面SQL语句正确的是？\n\n\n\n其中\n\n\n\n表a：jigou(机构)，kehhao(客户号)，jiaoyrq(交易日期),jioyje(交易金额)\n\n\n\n表b: kehhao(客户号)，表b为VIP客户号表\n\n\n\nSelect ______ from a inner join b on A、kehhao = B、kehhao ________\n\n\n\nA、Count(A、kehhao), group by jigou\n\n\n\nB、Count(A、kehhao), order by jigou\n\n\n\nC、Sum(A、kehhao), order by jigou\n\n\n\nD、Count(A、kehhao), having jigou\n\n\n\nE.以上都不正确\n\n\n\n','解答：A\n\n\n\n因为是统计各个分机构的VIP客户数量 所以要按照机构进行分组，而有多少条记录那么就有多少\n\n\n\n个VIP客户所以使用count\n\n\n\n','2','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000671,'SQL语言中修改表结构的命令是？\n\n\n\nA、MODIFY TABLE\n\n\n\nB、MODIFY STRUCTURE\n\n\n\nC、ALTER TABLE\n\n\n\nD、ALTER STRUCTURE\n\n\n\n','解答：C\n\n\n\n','3','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000672,'Delete和 truncate 都可以用来删除表内容，一下描述正确的是？\n\n\n\nA、Truncate 不需要 rollbacksegment\n\n\n\nB、Delete 需要rollbacksegment\n\n\n\nC、Truncate在 提交commit之前仍可回滚\n\n\n\nD、Truncate还可以删除表结构\n\n\n\n','解答：AB\n\n\n\nTRUNCATE TABLE 语句:删除表中所有的数据并且释放表的存储空间，可以使用 DELETE 语句删除数据，DELETE产生rollback，如果删除大数据量的表速度会很慢，同时会占用很多的rollback segments .truncate 是DDL操作，不产生rollback，速度快一些\n\n\n\n','2','chose','后台',NULL,'2017-03-12 14:55:49',NULL),(00000000673,'请给出两个影响系统效率的函数（选两个答案）。\n\n\n\nA、UPPER\n\n\n\nB、SUM\n\n\n\nC、MAX\n\n\n\nD、LOWER\n\n\n\n','解答：BC\n\n\n\n','1','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000674,'QUESTION. description of the students table: sid_id number start_date date end_date date which two function are valid on the start_date column?_________。\n\n\n\nA、 sum(start_date) B、 avg(start_date) C、 count(start_date) D、 avg(start_date,end_date) E. min(start_date)\n\n\n\n','解答：CE\n\n\n\nsum和avg要求数字数据类型。\n\n\n\n','4','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000675,'which are DML statements(choose all that apply)______. A、commit\n\n\n\nB、merge\n\n\n\nC、update\n\n\n\nD、delete\n\n\n\nE.creat\n\n\n\nF.drop\n\n\n\n','解答：BCD\n\n\n\nDML：Data manipulation language 数据操众语言 insert delete update merge\n\n\n\nDDL：data definition language 数据定义语言 create alter drop\n\n\n\nDCL：data control language 数据控制语言 grant revoke 230、Select 语句中用来连接字符串的符号是______. A、 “+” B、 “&” C、“||” D、“|”\n\n\n\n解答：C\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000676,'从 “员工” 表的“姓名”字段中找出名字包含“玛丽”的人，下面哪条select语句正确：（ ）\n\n\n\nA、 Select * from员工 where 姓名 =’_玛丽_’\n\n\n\nB 、Select * from员工 where 姓名 =’%玛丽_’\n\n\n\nC、 Select * from员工 where 姓名 like ‘_玛丽%’\n\n\n\nD、 Select * from员工 where 姓名 like ‘%玛丽%’\n\n\n\n','解答：D\n\n\n\nLIKE 运算选择类似的值，选择条件可以包含字符或数字，“%” 代表一个或多个字符，“_” 代表一个字符。\n\n\n\n','2','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000677,'在关系数据库的询问优化中，事先处理文件，如排序、建立索引的目的是（）\n\n\n\nA优化表达式 B减少中间结果 C扩大缓冲数据 D减少扫描文件的时间\n\n\n\n','解答：D\n\n\n\n233. ','3','chose','前端',NULL,'2017-03-12 14:55:49',NULL),(00000000678,'表 CUSTOMER 包含如下列:\n\n\n\nCUSTOMER_ID NUMBER(9)\n\n\n\nLAST_NAME VARCHAR2(20)\n\n\n\nFIRST_NAME VARCHAR2(20)\n\n\n\nCREDIT_LIMIT NUMBER(9,2)\n\n\n\n如下代码：\n\n\n\nDECLARE\n\n\n\nCURSOR cust_cursor IS\n\n\n\nSELECT customer_id, last_name, first_name\n\n\n\nFROM customer;\n\n\n\ncust_rec cust_cursor%ROWTYPE;\n\n\n\n你如何操纵 CUST_REC 中的记录? (选择1项)\n\n\n\nA、添加一个 LOOP 到游标声明中.\n\n\n\nB、在PL/SQL 块的执行部分，使用 INSERT INTO 语句.\n\n\n\nC、在PL/SQL 块的执行部分，使用一个 LOOP 和 FETCH 语句.\n\n\n\nD、在PL/SQL 块的执行部分，使用 SELECT 语句使用 INTO 操作.\n\n\n\n','解答:D\n\n\n\n%ROWTYPE操作符, 返回一个记录类型, 其数据类型和数据库表的数据结构相一致,\n\n\n\n在这里就和游标查询语句中的数据结果保持一致。\n\n\n\n例如: DECLARE CURSOR cust_cursor IS SELECT CUSTOMER_ID, last_name, first_name FROM customer; cust_rec cust_cursor%ROWTYPE; begin open cust_cursor; LOOP\n\n\n\nFETCH cust_cursor INTO cust_rec; EXIT WHEN cust_cursor%NOTFOUND; DBMS_OUTPUT.PUT_LINE(cust_reC、last_name); END LOOP; end;\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL),(00000000679,'定义存储过程如下：\n\n\n\nCREATE OR REPLACE PROCEDURE INSERT_TEAM\n\n\n\n(V_ID in NUMBER,V_CITY in VARCHER2 DEFAULT ‘AUSTIN’, V_NAME\n\n\n\nin VARCHER2)\n\n\n\nIS\n\n\n\nBEGIN\n\n\n\nINSERT INTO TEAM (id, city,name)\n\n\n\nVALUES (v_id,v_city,v_name);\n\n\n\nCOMMIT;\n\n\n\nEND;\n\n\n\n以下哪些PL/SQL语句能够正确调用该过程？（选择1项）\n\n\n\nA、 EXECUTE INSERT_TEAM;\n\n\n\nB、 EXECUTE INSERT_TEAM (V_NAME=.>”LONG HORNS”);\n\n\n\nC、 V_CITY=>”AUSTIN”;\n\n\n\nD、 EXECUTE INSERT_TEAM (3,”AUSTIN”,”LONG HORNS”)\n\n\n\n','解答：D\n\n\n\n\n\n','5','chose','Java语法',NULL,'2017-03-12 14:55:49',NULL);
/*!40000 ALTER TABLE `exercises` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `user_id` varchar(20) NOT NULL,
  `user_name` varchar(45) NOT NULL,
  `user_pw` varchar(45) NOT NULL,
  `user_info` varchar(200) DEFAULT NULL,
  `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_id_UNIQUE` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES ('u0001','Tony','password','Java Engineer','2017-03-09 04:00:25');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-03-12 23:10:36
